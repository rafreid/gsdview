---
phase: 24-minimap
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/renderer/renderer.js
  - src/renderer/index.html
autonomous: true

must_haves:
  truths:
    - "Clicking anywhere on minimap flies camera to that region of graph"
    - "Minimap updates in real-time as graph nodes are added or removed"
    - "Dragging on minimap continuously updates camera position"
    - "Mouse cursor changes to pointer when hovering minimap canvas"
  artifacts:
    - path: "src/renderer/renderer.js"
      provides: "Minimap click/drag navigation handlers"
      contains: "handleMinimapClick|handleMinimapDrag|navigateToMinimapPosition"
    - path: "src/renderer/index.html"
      provides: "Minimap canvas cursor styling"
      contains: "minimap-canvas.*cursor"
  key_links:
    - from: "minimap canvas click"
      to: "Graph.cameraPosition"
      via: "minimapToWorld + flyToNodeSmooth pattern"
      pattern: "Graph\\.cameraPosition.*minimapToWorld"
    - from: "applyIncrementalUpdate"
      to: "calculateMinimapBounds"
      via: "Bounds recalculation on graph change"
      pattern: "calculateMinimapBounds"
---

<objective>
Add click-to-navigate functionality to the minimap so users can quickly jump to any region of the graph by clicking on the minimap.

Purpose: Completes the minimap feature by enabling fast navigation. Users click where they want to go on the overview, and the camera smoothly flies to that location.

Output: Clickable minimap with smooth camera navigation and drag support for continuous positioning.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/24-minimap/24-01-SUMMARY.md (for minimap rendering context)

Key patterns from 24-01:
- minimapCanvas, minimapCtx - canvas element and 2D context
- minimapToWorld(canvasX, canvasY) - converts canvas coords to world coords
- calculateMinimapBounds() - recalculates graph bounds
- renderMinimap() - full minimap render
- Graph.cameraPosition(pos, lookAt, duration) - smooth camera transition

Existing navigation patterns:
- flyToNodeSmooth(nodeId, distance) for 800ms transitions
- zoomToOverview() for fitting entire graph
- is3D boolean for dimension mode handling
</context>

<tasks>

<task type="auto">
  <name>Task 1: Minimap click-to-navigate handler</name>
  <files>src/renderer/renderer.js</files>
  <action>
Add click navigation to minimap:

1. Create `navigateToMinimapPosition(canvasX, canvasY)` function:
```javascript
function navigateToMinimapPosition(canvasX, canvasY) {
  // Convert canvas position to world coordinates
  const worldPos = minimapToWorld(canvasX, canvasY);

  // Calculate appropriate camera distance based on current bounds
  const spanX = minimapBounds.maxX - minimapBounds.minX;
  const spanY = minimapBounds.maxY - minimapBounds.minY;
  const spanZ = minimapBounds.maxZ - minimapBounds.minZ;
  const maxSpan = Math.max(spanX, spanY, spanZ, 100);

  // Use a zoom level that shows good context (not too close, not too far)
  const distance = maxSpan * 0.3;

  if (is3D) {
    // 3D mode: position camera looking at clicked point
    Graph.cameraPosition(
      {
        x: worldPos.x + distance * 0.3,
        y: worldPos.y + distance * 0.3,
        z: distance
      },
      { x: worldPos.x, y: worldPos.y, z: 0 },
      800
    );
  } else {
    // 2D mode: position camera directly above
    Graph.cameraPosition(
      { x: worldPos.x, y: worldPos.y, z: distance + 100 },
      { x: worldPos.x, y: worldPos.y, z: 0 },
      800
    );
  }

  console.log('[Minimap] Navigate to:', worldPos.x.toFixed(0), worldPos.y.toFixed(0));
}
```

2. Create `handleMinimapClick(event)` function:
```javascript
function handleMinimapClick(event) {
  if (!minimapCanvas || minimapCollapsed) return;

  const rect = minimapCanvas.getBoundingClientRect();
  const canvasX = event.clientX - rect.left;
  const canvasY = event.clientY - rect.top;

  navigateToMinimapPosition(canvasX, canvasY);
}
```

3. Add click listener in `initMinimap()` function:
```javascript
// In initMinimap(), after collapse toggle setup:
minimapCanvas.addEventListener('click', handleMinimapClick);
```
  </action>
  <verify>
Click on minimap: Camera smoothly flies to the clicked region of the graph. Click on different areas, verify camera navigates to corresponding world positions.
  </verify>
  <done>
Clicking on minimap navigates camera to that world position with smooth 800ms transition.
  </done>
</task>

<task type="auto">
  <name>Task 2: Minimap drag navigation for continuous positioning</name>
  <files>src/renderer/renderer.js</files>
  <action>
Add drag support for smooth continuous navigation:

1. Add drag state variables (near minimap state):
```javascript
let minimapDragging = false;
```

2. Create drag handlers:
```javascript
function handleMinimapMouseDown(event) {
  if (!minimapCanvas || minimapCollapsed) return;

  // Only left click
  if (event.button !== 0) return;

  minimapDragging = true;
  minimapCanvas.style.cursor = 'grabbing';

  // Navigate to initial position
  const rect = minimapCanvas.getBoundingClientRect();
  const canvasX = event.clientX - rect.left;
  const canvasY = event.clientY - rect.top;
  navigateToMinimapPositionInstant(canvasX, canvasY);

  event.preventDefault();
}

function handleMinimapMouseMove(event) {
  if (!minimapDragging || !minimapCanvas) return;

  const rect = minimapCanvas.getBoundingClientRect();
  const canvasX = event.clientX - rect.left;
  const canvasY = event.clientY - rect.top;

  // Clamp to canvas bounds
  const clampedX = Math.max(MINIMAP_PADDING, Math.min(canvasX, minimapCanvas.width / (window.devicePixelRatio || 1) - MINIMAP_PADDING));
  const clampedY = Math.max(MINIMAP_PADDING, Math.min(canvasY, minimapCanvas.height / (window.devicePixelRatio || 1) - MINIMAP_PADDING));

  navigateToMinimapPositionInstant(clampedX, clampedY);
}

function handleMinimapMouseUp(event) {
  if (minimapDragging) {
    minimapDragging = false;
    if (minimapCanvas) {
      minimapCanvas.style.cursor = 'pointer';
    }
  }
}

function handleMinimapMouseLeave(event) {
  // End drag if mouse leaves canvas while dragging
  handleMinimapMouseUp(event);
}
```

3. Create instant navigation (no animation for drag):
```javascript
function navigateToMinimapPositionInstant(canvasX, canvasY) {
  const worldPos = minimapToWorld(canvasX, canvasY);

  const spanX = minimapBounds.maxX - minimapBounds.minX;
  const spanY = minimapBounds.maxY - minimapBounds.minY;
  const maxSpan = Math.max(spanX, spanY, 100);
  const distance = maxSpan * 0.3;

  if (is3D) {
    Graph.cameraPosition(
      {
        x: worldPos.x + distance * 0.3,
        y: worldPos.y + distance * 0.3,
        z: distance
      },
      { x: worldPos.x, y: worldPos.y, z: 0 },
      0  // Instant for drag
    );
  } else {
    Graph.cameraPosition(
      { x: worldPos.x, y: worldPos.y, z: distance + 100 },
      { x: worldPos.x, y: worldPos.y, z: 0 },
      0
    );
  }
}
```

4. Update `initMinimap()` to add drag listeners:
```javascript
// In initMinimap(), after click listener:
minimapCanvas.addEventListener('mousedown', handleMinimapMouseDown);
minimapCanvas.addEventListener('mousemove', handleMinimapMouseMove);
minimapCanvas.addEventListener('mouseup', handleMinimapMouseUp);
minimapCanvas.addEventListener('mouseleave', handleMinimapMouseLeave);
```

5. Also listen for global mouseup to handle drag ending outside canvas:
```javascript
// In initMinimap():
document.addEventListener('mouseup', () => {
  if (minimapDragging) {
    minimapDragging = false;
    if (minimapCanvas) {
      minimapCanvas.style.cursor = 'pointer';
    }
  }
});
```
  </action>
  <verify>
Click and drag on minimap: Camera continuously follows mouse position on minimap. Cursor changes to grabbing while dragging. Releasing mouse stops the drag behavior.
  </verify>
  <done>
Dragging on minimap continuously updates camera position for smooth exploration. Cursor feedback indicates drag state.
  </done>
</task>

<task type="auto">
  <name>Task 3: Minimap cursor styling and polish</name>
  <files>src/renderer/index.html</files>
  <action>
Add cursor styling and visual polish:

1. Update minimap canvas CSS to show pointer cursor:
```css
#minimap-canvas {
  display: block;
  width: 200px;
  height: 150px;
  margin: 10px;
  background: rgba(0, 0, 0, 0.3);
  border-radius: 4px;
  cursor: pointer;
}

#minimap-canvas:active {
  cursor: grabbing;
}
```

2. Add hover highlight effect:
```css
#minimap-panel:hover {
  border-color: rgba(78, 205, 196, 0.5);
}
```

3. Add transition for smoother interactions:
```css
#minimap-panel {
  /* existing styles... */
  transition: height 0.3s ease, opacity 0.3s ease, border-color 0.2s ease;
}
```
  </action>
  <verify>
Hover over minimap canvas: Cursor shows pointer. Click and hold: Cursor shows grabbing. Panel border highlights on hover.
  </verify>
  <done>
Minimap has proper cursor feedback and visual polish for interactive states.
  </done>
</task>

</tasks>

<verification>
1. Click on minimap
   - Camera smoothly flies to that region (800ms animation)
   - Works in both 3D and 2D modes

2. Click and drag on minimap
   - Camera instantly follows mouse position
   - Cursor changes to grabbing during drag
   - Releasing stops the drag

3. Drag outside canvas while dragging
   - Drag properly ends when releasing mouse anywhere

4. Graph changes (file created/deleted)
   - Minimap bounds update to include new nodes
   - Deleted nodes no longer appear

5. Toggle between 3D and 2D mode
   - Minimap click navigation works in both modes
   - Camera positioning appropriate for each mode
</verification>

<success_criteria>
- Single click navigates camera to clicked minimap position
- Drag continuously updates camera position
- Proper cursor feedback (pointer, grabbing)
- Navigation works in both 3D and 2D modes
- Smooth transitions for click, instant for drag
- Minimap bounds update when graph changes
</success_criteria>

<output>
After completion, create `.planning/phases/24-minimap/24-02-SUMMARY.md`
</output>

---
phase: 24-minimap
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/renderer/renderer.js
  - src/renderer/index.html
autonomous: true

must_haves:
  truths:
    - "User can see minimap panel showing bird's-eye overview of entire graph"
    - "Minimap displays simplified dots for each node position"
    - "Minimap shows highlighted rectangle indicating current camera viewport"
    - "Minimap is positioned in bottom-right corner without obstructing main view"
    - "Minimap updates when graph data changes"
  artifacts:
    - path: "src/renderer/renderer.js"
      provides: "Minimap rendering logic and viewport calculation"
      contains: "renderMinimap|calculateMinimapBounds|updateMinimapViewport"
    - path: "src/renderer/index.html"
      provides: "Minimap canvas element and CSS styling"
      contains: "minimap-panel|minimap-canvas"
  key_links:
    - from: "RAF loop"
      to: "renderMinimap"
      via: "requestAnimationFrame callback"
      pattern: "requestAnimationFrame.*renderMinimap|minimapRafId"
    - from: "graph data change"
      to: "calculateMinimapBounds"
      via: "Called inside renderMinimap"
      pattern: "calculateMinimapBounds"
---

<objective>
Implement minimap panel showing a bird's-eye 2D overview of the entire graph with a viewport indicator showing the current camera position.

Purpose: Large graphs are hard to navigate. The minimap provides spatial awareness - users can see where they are relative to the whole graph and identify dense regions to explore.

Output: Minimap panel with canvas rendering nodes as dots and camera viewport as highlighted rectangle.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/renderer/renderer.js (lines 5500-5550 for zoomToOverview bounding box calculation, lines 1745-1750 for Graph.cameraPosition access)
@src/renderer/index.html (panel positioning patterns)

Key patterns:
- currentGraphData.nodes contains all nodes with x, y, z coordinates
- Graph.cameraPosition() returns {x, y, z} of current camera
- zoomToOverview() already calculates bounding box of all nodes (reuse pattern)
- Panels use fixed positioning with transform for show/hide
- Color legend at bottom-left, statistics at right, activity at bottom
- Minimap should go bottom-right corner to avoid overlap
</context>

<tasks>

<task type="auto">
  <name>Task 1: Minimap UI panel and canvas element</name>
  <files>src/renderer/index.html</files>
  <action>
Add minimap panel to index.html:

1. Add minimap container element (positioned bottom-right, above color legend z-index):
```html
<div id="minimap-panel">
  <div id="minimap-header">
    <span class="minimap-title">Minimap</span>
    <button id="minimap-toggle-btn" title="Toggle minimap">-</button>
  </div>
  <canvas id="minimap-canvas" width="200" height="150"></canvas>
</div>
```

2. Add CSS styles for minimap panel:
```css
/* Minimap Panel */
#minimap-panel {
  position: fixed;
  bottom: 20px;
  right: 20px;
  width: 220px;
  background: rgba(26, 26, 46, 0.95);
  border: 1px solid #333;
  border-radius: 8px;
  z-index: 100;
  overflow: hidden;
  transition: height 0.3s ease, opacity 0.3s ease;
}

#minimap-panel.collapsed {
  height: 32px;
}

#minimap-panel.collapsed #minimap-canvas {
  display: none;
}

#minimap-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 6px 10px;
  background: rgba(0, 0, 0, 0.3);
  cursor: pointer;
  user-select: none;
}

#minimap-header:hover {
  background: rgba(78, 205, 196, 0.1);
}

.minimap-title {
  font-size: 11px;
  font-weight: 600;
  color: #4ECDC4;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

#minimap-toggle-btn {
  background: none;
  border: none;
  color: #888;
  font-size: 14px;
  cursor: pointer;
  width: 20px;
  height: 20px;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: color 0.2s;
}

#minimap-toggle-btn:hover {
  color: #4ECDC4;
}

#minimap-canvas {
  display: block;
  width: 200px;
  height: 150px;
  margin: 10px;
  background: rgba(0, 0, 0, 0.3);
  border-radius: 4px;
}

/* Adjust minimap position when activity panel is open */
#minimap-panel.activity-open {
  bottom: 200px;
}

/* Adjust minimap position when details panel is open */
#minimap-panel.details-open {
  right: 440px;
}
```

3. Position minimap to avoid overlapping with existing panels:
   - Right side: 20px from edge (moves left when details panel opens)
   - Bottom: 20px from edge (moves up when activity panel opens)
   - z-index 100 (same as color legend)
  </action>
  <verify>
Visual check: Minimap panel appears in bottom-right corner with header and canvas. Clicking header collapses/expands the panel. Panel doesn't overlap with color legend (bottom-left) or interfere with graph interaction.
  </verify>
  <done>
Minimap panel UI visible in bottom-right corner with collapsible header and canvas element ready for rendering.
  </done>
</task>

<task type="auto">
  <name>Task 2a: Minimap coordinate system and bounds calculation</name>
  <files>src/renderer/renderer.js</files>
  <action>
Add minimap state and coordinate transformation functions to renderer.js:

1. Add minimap state variables near other state (after bookmark variables ~line 117):
```javascript
// Minimap state
let minimapCollapsed = false;
let minimapCanvas = null;
let minimapCtx = null;
let minimapBounds = { minX: 0, maxX: 0, minY: 0, maxY: 0, minZ: 0, maxZ: 0 };
const MINIMAP_PADDING = 10; // Padding inside canvas
let minimapRafId = null;
```

2. Create `calculateMinimapBounds()` function - iterates all nodes to find min/max for each axis:
```javascript
function calculateMinimapBounds() {
  // Initialize with opposite extremes so any value will replace them
  let minX = Infinity, maxX = -Infinity;
  let minY = Infinity, maxY = -Infinity;
  let minZ = Infinity, maxZ = -Infinity;

  // Find bounding box by checking each node's position
  currentGraphData.nodes.forEach(node => {
    if (node.x !== undefined) {
      minX = Math.min(minX, node.x);
      maxX = Math.max(maxX, node.x);
      minY = Math.min(minY, node.y);
      maxY = Math.max(maxY, node.y);
      minZ = Math.min(minZ, node.z || 0);
      maxZ = Math.max(maxZ, node.z || 0);
    }
  });

  // Handle empty or single-node graphs - default to origin
  if (minX === Infinity) {
    minX = maxX = minY = maxY = minZ = maxZ = 0;
  }

  // Ensure some minimum span to avoid division by zero
  const minSpan = 50;
  if (maxX - minX < minSpan) { minX -= minSpan/2; maxX += minSpan/2; }
  if (maxY - minY < minSpan) { minY -= minSpan/2; maxY += minSpan/2; }

  minimapBounds = { minX, maxX, minY, maxY, minZ, maxZ };
  return minimapBounds;
}
```

3. Create `worldToMinimap(worldX, worldY)` - linear mapping from world to canvas:
```javascript
// Formula: canvasX = PADDING + ((worldX - minX) / (maxX - minX)) * canvasWidth
// This scales world coordinates [minX, maxX] to canvas coordinates [PADDING, canvasWidth - PADDING]
function worldToMinimap(worldX, worldY) {
  if (!minimapCanvas) return { x: 0, y: 0 };

  const canvasW = minimapCanvas.width - MINIMAP_PADDING * 2;
  const canvasH = minimapCanvas.height - MINIMAP_PADDING * 2;

  const { minX, maxX, minY, maxY } = minimapBounds;
  const spanX = maxX - minX || 1;  // Avoid division by zero
  const spanY = maxY - minY || 1;

  // Linear interpolation: normalized position [0,1] scaled to canvas size
  const x = MINIMAP_PADDING + ((worldX - minX) / spanX) * canvasW;
  const y = MINIMAP_PADDING + ((worldY - minY) / spanY) * canvasH;

  return { x, y };
}
```

4. Create `minimapToWorld(canvasX, canvasY)` - inverse transformation for click handling:
```javascript
// Formula: worldX = minX + ((canvasX - PADDING) / canvasWidth) * (maxX - minX)
// This is the inverse of worldToMinimap, mapping canvas clicks back to world positions
function minimapToWorld(canvasX, canvasY) {
  if (!minimapCanvas) return { x: 0, y: 0 };

  const canvasW = minimapCanvas.width - MINIMAP_PADDING * 2;
  const canvasH = minimapCanvas.height - MINIMAP_PADDING * 2;

  const { minX, maxX, minY, maxY } = minimapBounds;
  const spanX = maxX - minX || 1;
  const spanY = maxY - minY || 1;

  // Inverse linear interpolation: canvas position to world position
  const x = minX + ((canvasX - MINIMAP_PADDING) / canvasW) * spanX;
  const y = minY + ((canvasY - MINIMAP_PADDING) / canvasH) * spanY;

  return { x, y };
}
```
  </action>
  <verify>
No visual verification yet - these are helper functions. Verify they exist in code and have no syntax errors by checking the file loads without console errors.
  </verify>
  <done>
Minimap coordinate system established: calculateMinimapBounds() computes graph extents, worldToMinimap() and minimapToWorld() provide bidirectional coordinate transformation.
  </done>
</task>

<task type="auto">
  <name>Task 2b: Minimap rendering and RAF update loop</name>
  <files>src/renderer/renderer.js</files>
  <action>
Add minimap rendering functions and continuous update loop:

1. Create `drawMinimapViewport(ctx)` to show current camera view area:
```javascript
function drawMinimapViewport(ctx) {
  if (!Graph || !Graph.cameraPosition) return;

  const camPos = Graph.cameraPosition();
  if (!camPos) return;

  // Estimate viewport size based on camera Z distance (farther = sees more)
  // Camera at z=500 sees roughly 500 world units; at z=100 sees roughly 100 units
  const camDist = Math.abs(camPos.z) || 100;
  const viewportSize = Math.min(camDist * 0.5, 200);

  // Calculate viewport bounds in world coordinates (XY plane projection)
  const viewMinX = camPos.x - viewportSize;
  const viewMaxX = camPos.x + viewportSize;
  const viewMinY = camPos.y - viewportSize;
  const viewMaxY = camPos.y + viewportSize;

  // Convert to canvas coordinates
  const topLeft = worldToMinimap(viewMinX, viewMinY);
  const bottomRight = worldToMinimap(viewMaxX, viewMaxY);

  // Ensure minimum visible rectangle
  const rectW = Math.max(bottomRight.x - topLeft.x, 10);
  const rectH = Math.max(bottomRight.y - topLeft.y, 10);

  // Draw viewport rectangle with stroke and semi-transparent fill
  ctx.strokeStyle = 'rgba(78, 205, 196, 0.8)'; // Teal
  ctx.lineWidth = 2;
  ctx.strokeRect(topLeft.x, topLeft.y, rectW, rectH);
  ctx.fillStyle = 'rgba(78, 205, 196, 0.1)';
  ctx.fillRect(topLeft.x, topLeft.y, rectW, rectH);
}
```

2. Create `renderMinimap()` function to draw nodes and viewport:
```javascript
function renderMinimap() {
  if (!minimapCanvas || !minimapCtx || minimapCollapsed) return;

  const ctx = minimapCtx;
  const w = minimapCanvas.width;
  const h = minimapCanvas.height;

  // Clear canvas with dark background
  ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
  ctx.fillRect(0, 0, w, h);

  // Recalculate bounds (handles graph changes automatically)
  calculateMinimapBounds();

  // Draw each node as a small dot
  currentGraphData.nodes.forEach(node => {
    if (node.x === undefined) return;

    const pos = worldToMinimap(node.x, node.y);

    // Color based on node type (simplified color scheme)
    let color = '#888888';  // Default gray
    if (node.sourceType === 'src') {
      color = '#5B9BD5';    // Blue for source files
    } else if (node.sourceType === 'planning') {
      color = '#BB8FCE';    // Purple for planning files
    } else if (node.type === 'commit') {
      color = '#9B59B6';    // Purple for commits
    }

    // Highlight selected node with larger teal dot
    if (selectedNode && node.id === selectedNode.id) {
      ctx.beginPath();
      ctx.arc(pos.x, pos.y, 4, 0, Math.PI * 2);
      ctx.fillStyle = '#4ECDC4';  // Teal for selected
      ctx.fill();
    } else {
      // Regular node as small dot
      ctx.beginPath();
      ctx.arc(pos.x, pos.y, 2, 0, Math.PI * 2);
      ctx.fillStyle = color;
      ctx.fill();
    }
  });

  // Draw viewport rectangle showing current camera view
  drawMinimapViewport(ctx);
}
```

3. Create `startMinimapUpdateLoop()` for continuous viewport tracking via RAF:
```javascript
// Uses requestAnimationFrame to continuously re-render minimap
// This ensures viewport rectangle updates smoothly as camera moves
// RAF is preferred over controls listeners because:
// - Works with all camera movement sources (orbit, pan, zoom, programmatic)
// - Smoother updates than event-driven approach
// - Self-throttles to display refresh rate
function startMinimapUpdateLoop() {
  function update() {
    renderMinimap();
    minimapRafId = requestAnimationFrame(update);
  }
  minimapRafId = requestAnimationFrame(update);
}

function stopMinimapUpdateLoop() {
  if (minimapRafId) {
    cancelAnimationFrame(minimapRafId);
    minimapRafId = null;
  }
}
```

4. Create `initMinimap()` function to set up canvas and start updates:
```javascript
function initMinimap() {
  minimapCanvas = document.getElementById('minimap-canvas');
  if (!minimapCanvas) return;

  minimapCtx = minimapCanvas.getContext('2d');

  // Handle retina/HiDPI displays by scaling canvas
  const dpr = window.devicePixelRatio || 1;
  const rect = minimapCanvas.getBoundingClientRect();
  minimapCanvas.width = rect.width * dpr;
  minimapCanvas.height = rect.height * dpr;
  minimapCtx.scale(dpr, dpr);

  // Collapse toggle handler
  const header = document.getElementById('minimap-header');
  const toggleBtn = document.getElementById('minimap-toggle-btn');

  header?.addEventListener('click', () => {
    minimapCollapsed = !minimapCollapsed;
    const panel = document.getElementById('minimap-panel');
    if (panel) {
      panel.classList.toggle('collapsed', minimapCollapsed);
    }
    if (toggleBtn) {
      toggleBtn.textContent = minimapCollapsed ? '+' : '-';
    }
    if (!minimapCollapsed) {
      renderMinimap();
    }
  });

  // Initial render
  renderMinimap();

  // Start continuous RAF update loop for viewport tracking
  startMinimapUpdateLoop();

  console.log('[Minimap] Initialized');
}
```

5. Call initMinimap() in the DOMContentLoaded handler (after other panel initializations):
```javascript
// In DOMContentLoaded handler, add after other init calls:
initMinimap();
```

6. Update minimap position when other panels open/close:
- In activity panel toggle handler, add: `document.getElementById('minimap-panel')?.classList.toggle('activity-open', isOpen);`
- In details panel show/hide, add: `document.getElementById('minimap-panel')?.classList.toggle('details-open', visible);`
  </action>
  <verify>
Visual check: Minimap renders nodes as colored dots. Viewport rectangle visible and moves when camera moves. Selected node appears larger/teal colored. Collapse toggle works. Minimap repositions when activity or details panels open.
  </verify>
  <done>
Minimap renders graph overview with node dots and viewport indicator. RAF loop provides continuous viewport updates as camera moves. Collapse toggle functional.
  </done>
</task>

</tasks>

<verification>
1. Launch app and load a project
   - Minimap appears in bottom-right corner
   - Shows dots representing nodes (blue for src, purple for planning)

2. Move camera around (orbit, pan, zoom)
   - Viewport rectangle moves correspondingly on minimap
   - When zoomed out, viewport rectangle is larger
   - When zoomed in, viewport rectangle is smaller

3. Select a node
   - Selected node appears as larger teal dot on minimap

4. Click minimap header
   - Panel collapses, canvas hides
   - Click again to expand

5. Open activity panel
   - Minimap moves up to avoid overlap

6. Open details panel (click a node)
   - Minimap moves left to avoid overlap
</verification>

<success_criteria>
- Minimap panel visible in bottom-right corner with collapsible header
- Node positions rendered as colored dots on 2D canvas
- Viewport rectangle shows current camera view area
- Viewport updates in real-time as camera moves (via RAF loop)
- Selected node highlighted on minimap
- Panel repositions when other panels open
- Minimap doesn't obstruct main graph interaction
</success_criteria>

<output>
After completion, create `.planning/phases/24-minimap/24-01-SUMMARY.md`
</output>

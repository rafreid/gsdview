---
phase: 17-search-polish
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/renderer/index.html
  - src/renderer/renderer.js
autonomous: true

must_haves:
  truths:
    - "User can press Escape to close modal from any focused element"
    - "User can press Ctrl+F to open search input and focus cursor"
    - "User can type search query and see matching text highlighted in diff view"
    - "Search shows match count (e.g., '3 of 12 matches')"
    - "Search highlights update in real-time as user types"
  artifacts:
    - path: "src/renderer/index.html"
      provides: "Search bar UI in modal header"
      contains: "#modal-search-container"
    - path: "src/renderer/renderer.js"
      provides: "Search state and highlight logic"
      exports: ["currentSearchQuery", "searchMatches", "currentMatchIndex"]
      contains: "highlightSearchMatches"
  key_links:
    - from: "src/renderer/renderer.js (Ctrl+F handler)"
      to: "#modal-search-input"
      via: "focus() on search input"
      pattern: "modal-search-input.*focus"
    - from: "src/renderer/renderer.js (search input handler)"
      to: "diff view content"
      via: "highlightSearchMatches() wraps matches in <mark>"
      pattern: "highlightSearchMatches.*<mark>"
---

<objective>
Complete file inspector modal with keyboard shortcuts and in-modal search functionality.

Purpose: Enable efficient modal navigation (Esc to close) and content discovery (Ctrl+F search with real-time highlighting and match navigation).

Output: Fully polished file inspector with keyboard shortcuts and search capabilities, completing v1.2 milestone.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md

# Phase 16 summary - recent modal additions
@.planning/phases/16-file-context-metadata/16-01-SUMMARY.md
@.planning/phases/16-file-context-metadata/16-02-SUMMARY.md

# Current implementation
@src/renderer/index.html
@src/renderer/renderer.js
</context>

<tasks>

<task type="auto">
  <name>Add search bar to modal header</name>
  <files>src/renderer/index.html</files>
  <action>
Add search bar UI to file inspector modal header (between title and close button).

HTML structure:
```html
<!-- In .modal-header, after h2#inspector-title -->
<div id="modal-search-container" class="hidden">
  <input type="text" id="modal-search-input" placeholder="Search in file...">
  <span id="modal-search-info"></span>
  <div id="modal-search-nav">
    <button id="search-prev" title="Previous match">▲</button>
    <button id="search-next" title="Next match">▼</button>
  </div>
  <button id="search-close" title="Close search">×</button>
</div>
```

CSS styles (in &lt;style&gt; section):
```css
#modal-search-container {
  display: flex;
  align-items: center;
  gap: 8px;
  flex: 1;
  max-width: 400px;
  margin: 0 16px;
}

#modal-search-container.hidden {
  display: none;
}

#modal-search-input {
  flex: 1;
  height: 28px;
  padding: 0 8px;
  background: #2a2a4e;
  border: 1px solid #555;
  border-radius: 4px;
  color: #eee;
  font-size: 12px;
  outline: none;
}

#modal-search-input:focus {
  border-color: #4ECDC4;
  box-shadow: 0 0 0 2px rgba(78, 205, 196, 0.2);
}

#modal-search-info {
  font-size: 11px;
  color: #888;
  min-width: 60px;
  text-align: center;
}

#modal-search-nav {
  display: flex;
  gap: 2px;
}

#modal-search-nav button,
#search-close {
  width: 24px;
  height: 24px;
  padding: 0;
  background: transparent;
  border: 1px solid #555;
  border-radius: 3px;
  color: #888;
  font-size: 12px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s;
}

#modal-search-nav button:hover,
#search-close:hover {
  border-color: #4ECDC4;
  color: #4ECDC4;
  background: rgba(78, 205, 196, 0.1);
}

#modal-search-nav button:disabled {
  opacity: 0.3;
  cursor: not-allowed;
}

/* Search match highlighting */
mark.search-match {
  background: rgba(243, 156, 18, 0.4);
  color: inherit;
  padding: 2px 0;
  border-radius: 2px;
}

mark.search-match.current {
  background: rgba(78, 205, 196, 0.6);
  box-shadow: 0 0 0 2px rgba(78, 205, 196, 0.3);
}
```

Why: Search bar needs to be visually integrated into modal header while remaining unobtrusive when hidden.
  </action>
  <verify>
Open index.html and confirm search container exists in modal header.
Search for "modal-search-container" and verify all CSS rules present.
  </verify>
  <done>
HTML contains #modal-search-container with input, info span, navigation buttons, and close button.
CSS includes all search-related styles (container, input, nav buttons, mark highlighting).
  </done>
</task>

<task type="auto">
  <name>Implement keyboard shortcuts and search logic</name>
  <files>src/renderer/renderer.js</files>
  <action>
Add search state, keyboard handlers, and highlighting logic.

1. Add search state variables (after existing state variables around line 90):
```javascript
// Modal search state
let currentSearchQuery = '';
let searchMatches = [];
let currentMatchIndex = -1;
```

2. Update existing Escape key handler (around line 3220) to ONLY handle modal when open:
```javascript
// Already correctly prioritizes modal - verify it closes modal first, then details panel
document.addEventListener('keydown', (e) => {
  if (e.key === 'Escape') {
    const modal = document.getElementById('file-inspector-modal');
    const searchContainer = document.getElementById('modal-search-container');

    // If search is open, close search first
    if (searchContainer && !searchContainer.classList.contains('hidden')) {
      closeModalSearch();
      return;
    }

    // If modal is open, close modal
    if (modal && !modal.classList.contains('hidden')) {
      closeFileInspector();
    } else {
      hideDetailsPanel();
    }
  }
});
```

3. Add Ctrl+F handler for modal search (NEW handler):
```javascript
// Ctrl+F opens search within modal
document.addEventListener('keydown', (e) => {
  if ((e.ctrlKey || e.metaKey) && e.key === 'f') {
    const modal = document.getElementById('file-inspector-modal');
    if (modal && !modal.classList.contains('hidden')) {
      e.preventDefault(); // Prevent browser search
      openModalSearch();
    }
  }
});
```

4. Add search functions (after closeFileInspector function around line 2552):
```javascript
// Open modal search
function openModalSearch() {
  const searchContainer = document.getElementById('modal-search-container');
  const searchInput = document.getElementById('modal-search-input');

  if (!searchContainer || !searchInput) return;

  searchContainer.classList.remove('hidden');
  searchInput.focus();
  searchInput.select(); // Select existing text if any

  // If there's already a query, re-run search
  if (searchInput.value) {
    performSearch(searchInput.value);
  }

  console.log('[Search] Opened');
}

// Close modal search
function closeModalSearch() {
  const searchContainer = document.getElementById('modal-search-container');
  const searchInput = document.getElementById('modal-search-input');

  if (!searchContainer || !searchInput) return;

  searchContainer.classList.add('hidden');
  searchInput.value = '';
  currentSearchQuery = '';
  searchMatches = [];
  currentMatchIndex = -1;

  // Remove all highlights
  clearSearchHighlights();

  console.log('[Search] Closed');
}

// Perform search in diff content
function performSearch(query) {
  if (!query || query.trim().length === 0) {
    clearSearchHighlights();
    updateSearchInfo(0, 0);
    return;
  }

  currentSearchQuery = query.trim();
  const diffSection = document.querySelector('#section-diff .section-content');

  if (!diffSection) {
    console.log('[Search] No diff content to search');
    return;
  }

  // Clear previous highlights
  clearSearchHighlights();

  // Get all diff lines
  const diffLines = diffSection.querySelectorAll('.diff-line-content');
  searchMatches = [];
  let matchCount = 0;

  // Case-insensitive search
  const lowerQuery = currentSearchQuery.toLowerCase();

  diffLines.forEach((line, lineIndex) => {
    const textContent = line.textContent;
    const lowerText = textContent.toLowerCase();
    let startIndex = 0;

    while (true) {
      const foundIndex = lowerText.indexOf(lowerQuery, startIndex);
      if (foundIndex === -1) break;

      searchMatches.push({
        lineElement: line,
        lineIndex,
        startIndex: foundIndex,
        length: currentSearchQuery.length
      });

      startIndex = foundIndex + 1;
    }
  });

  matchCount = searchMatches.length;

  // Highlight all matches
  if (matchCount > 0) {
    highlightSearchMatches();
    currentMatchIndex = 0;
    scrollToMatch(0);
  }

  updateSearchInfo(currentMatchIndex + 1, matchCount);
  console.log(`[Search] Found ${matchCount} matches for "${currentSearchQuery}"`);
}

// Highlight all search matches
function highlightSearchMatches() {
  searchMatches.forEach((match, index) => {
    const line = match.lineElement;
    const originalHTML = line.innerHTML;
    const textContent = line.textContent;

    // Extract text before, match, and after
    const before = textContent.substring(0, match.startIndex);
    const matchText = textContent.substring(match.startIndex, match.startIndex + match.length);
    const after = textContent.substring(match.startIndex + match.length);

    // Build highlighted HTML
    const isCurrent = index === currentMatchIndex;
    const markClass = isCurrent ? 'search-match current' : 'search-match';
    const newHTML = `${escapeHtml(before)}<mark class="${markClass}" data-match-index="${index}">${escapeHtml(matchText)}</mark>${escapeHtml(after)}`;

    line.innerHTML = newHTML;
  });
}

// Clear all search highlights
function clearSearchHighlights() {
  const diffSection = document.querySelector('#section-diff .section-content');
  if (!diffSection) return;

  const marks = diffSection.querySelectorAll('mark.search-match');
  marks.forEach(mark => {
    const parent = mark.parentElement;
    if (parent) {
      parent.textContent = parent.textContent; // Strip HTML, restore plain text
    }
  });
}

// Update search info display
function updateSearchInfo(current, total) {
  const infoSpan = document.getElementById('modal-search-info');
  const prevBtn = document.getElementById('search-prev');
  const nextBtn = document.getElementById('search-next');

  if (!infoSpan) return;

  if (total === 0) {
    infoSpan.textContent = 'No matches';
  } else {
    infoSpan.textContent = `${current} of ${total}`;
  }

  // Enable/disable navigation buttons
  if (prevBtn) prevBtn.disabled = total === 0;
  if (nextBtn) nextBtn.disabled = total === 0;
}

// Navigate to specific match
function scrollToMatch(index) {
  if (index < 0 || index >= searchMatches.length) return;

  currentMatchIndex = index;

  // Update highlights (remove 'current' from old, add to new)
  const allMarks = document.querySelectorAll('mark.search-match');
  allMarks.forEach((mark, i) => {
    mark.classList.toggle('current', i === currentMatchIndex);
  });

  // Scroll to match
  const match = searchMatches[currentMatchIndex];
  if (match && match.lineElement) {
    match.lineElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
  }

  updateSearchInfo(currentMatchIndex + 1, searchMatches.length);
}

// Navigate to next match
function nextMatch() {
  if (searchMatches.length === 0) return;
  const nextIndex = (currentMatchIndex + 1) % searchMatches.length;
  scrollToMatch(nextIndex);
}

// Navigate to previous match
function prevMatch() {
  if (searchMatches.length === 0) return;
  const prevIndex = currentMatchIndex === 0 ? searchMatches.length - 1 : currentMatchIndex - 1;
  scrollToMatch(prevIndex);
}
```

5. Add event listeners (at end of file, around line 3230+):
```javascript
// Modal search event listeners
document.getElementById('modal-search-input')?.addEventListener('input', (e) => {
  performSearch(e.target.value);
});

document.getElementById('search-prev')?.addEventListener('click', prevMatch);
document.getElementById('search-next')?.addEventListener('click', nextMatch);
document.getElementById('search-close')?.addEventListener('click', closeModalSearch);

// Enter key navigates to next match
document.getElementById('modal-search-input')?.addEventListener('keydown', (e) => {
  if (e.key === 'Enter') {
    e.preventDefault();
    if (e.shiftKey) {
      prevMatch();
    } else {
      nextMatch();
    }
  }
});
```

6. Clear search when modal closes (in closeFileInspector function):
```javascript
function closeFileInspector() {
  const overlay = document.getElementById('file-inspector-overlay');
  const modal = document.getElementById('file-inspector-modal');

  overlay.classList.remove('visible');
  setTimeout(() => {
    overlay.classList.add('hidden');
  }, 200);
  modal.classList.add('hidden');

  // Clear search state
  closeModalSearch(); // ADD THIS LINE

  inspectorNode = null;
  console.log('[Inspector] Closed');
}
```

Why: Real-time search with highlighting provides instant feedback. Match navigation (Enter/Shift+Enter, arrow buttons) enables efficient content scanning. Escape key priority (search → modal → details panel) follows expected UX patterns.
  </action>
  <verify>
1. Run `npm start` and open a project
2. Double-click any file node to open inspector modal
3. Press Esc - modal should close
4. Open modal again, press Ctrl+F - search bar should appear and focus
5. Type a search term - matches should highlight in real-time
6. Check match count displays (e.g., "3 of 12")
7. Press Enter - should navigate to next match
8. Press Shift+Enter - should navigate to previous match
9. Click ▲/▼ buttons - should navigate matches
10. Press Esc while search open - should close search, not modal
11. Press Esc again - should close modal
  </verify>
  <done>
Ctrl+F opens search bar with focused input.
Search input highlights matching text in diff view with &lt;mark&gt; tags.
Match count displays as "N of M" format.
Escape key closes search first, then modal on second press.
Enter/Shift+Enter and arrow buttons navigate between matches.
Current match has distinct highlight (teal vs orange).
  </done>
</task>

</tasks>

<verification>
End-to-end flow:
1. Launch app, open project, double-click file node
2. Press Ctrl+F → search bar appears, input focused
3. Type search query → matches highlight instantly with orange background
4. Current match highlighted with teal background, others orange
5. Match counter shows "1 of N" in search bar
6. Press Enter → navigates to next match, scrolls into view
7. Press Shift+Enter → navigates to previous match
8. Click ▲/▼ navigation buttons → also navigates matches
9. Press Esc → search bar closes, highlights clear
10. Press Esc again → modal closes completely

Requirements coverage:
- MOD-03: Escape key closes modal ✓
- MOD-04: Ctrl+F opens search within modal ✓
- CTX-05: Search input filters/highlights content ✓
</verification>

<success_criteria>
User can press Escape to close modal from any state.
User can press Ctrl+F (or Cmd+F on Mac) to open search within modal.
Search input appears in modal header with focus.
Typing in search input highlights matching text in real-time.
Match count displays in format "N of M matches".
Current match has distinct highlight color from other matches.
Enter key navigates to next match.
Shift+Enter navigates to previous match.
Navigation buttons (▲/▼) work for match navigation.
Pressing Escape while search is open closes search first, modal second.
All v1.2 requirements (MOD-01-04, DFE-01-05, TRE-01-05, CTX-01-07) complete.
</success_criteria>

<output>
After completion, create `.planning/phases/17-search-polish/17-01-SUMMARY.md`
</output>

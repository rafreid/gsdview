---
phase: 09-heat-map-visualization
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/renderer/renderer.js
autonomous: true

must_haves:
  truths:
    - "Recently changed files display hot color (red/orange glow)"
    - "File heat color transitions from hot to cool over time"
  artifacts:
    - path: "src/renderer/renderer.js"
      provides: "Heat state tracking, color gradient, decay animation"
      contains: "nodeHeatMap"
  key_links:
    - from: "addActivityEntry"
      to: "nodeHeatMap"
      via: "heat state update on file change"
      pattern: "nodeHeatMap\\.set"
    - from: "heat animation loop"
      to: "material.color"
      via: "calculateHeatColor and requestAnimationFrame"
      pattern: "requestAnimationFrame.*heat"
---

<objective>
Implement heat map visualization core: track file change timestamps, calculate heat colors based on elapsed time, and animate heat decay continuously so recently changed files glow hot (red/orange) and gradually cool down to their normal color.

Purpose: HET-01 and HET-02 - Users can visually identify recently active files by heat color that decays over time
Output: Working heat visualization where changed files glow hot and cool down smoothly
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-activity-feed-change-indicators/08-02-SUMMARY.md
@src/renderer/renderer.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement heat state tracking and color gradient calculation</name>
  <files>src/renderer/renderer.js</files>
  <action>
Add heat state tracking and color calculation to renderer.js:

1. Add heat configuration constants near the top (after changeTypeColors):
```javascript
// Heat map configuration
const HEAT_MAX_DURATION = 300000; // 5 minutes default (ms) - time for full cool down
let heatDecayDuration = HEAT_MAX_DURATION; // User-configurable via slider

// Heat color gradient (hot to cool): red -> orange -> yellow -> normal
const heatGradient = [
  { pos: 0.0, color: 0xFF4444 },  // Hot red
  { pos: 0.3, color: 0xFF8C00 },  // Orange
  { pos: 0.6, color: 0xFFD700 },  // Yellow/gold
  { pos: 1.0, color: null }       // null = use node's original color
];

// Track heat state per node: nodeId -> { lastChangeTime, originalColor }
const nodeHeatMap = new Map();
```

2. Add calculateHeatColor function:
```javascript
// Calculate heat color based on time elapsed since last change
function calculateHeatColor(nodeId, originalColorHex) {
  const heatState = nodeHeatMap.get(nodeId);
  if (!heatState) return originalColorHex;

  const elapsed = Date.now() - heatState.lastChangeTime;
  const progress = Math.min(elapsed / heatDecayDuration, 1.0);

  // Find gradient segment
  for (let i = 0; i < heatGradient.length - 1; i++) {
    const start = heatGradient[i];
    const end = heatGradient[i + 1];
    if (progress >= start.pos && progress <= end.pos) {
      const segmentProgress = (progress - start.pos) / (end.pos - start.pos);
      if (end.color === null) {
        // Interpolate to original color
        return lerpColor(start.color, originalColorHex, segmentProgress);
      }
      return lerpColor(start.color, end.color, segmentProgress);
    }
  }

  return originalColorHex; // Fully cooled
}
```

3. Add updateNodeHeat function to apply heat color to a node:
```javascript
// Apply heat color to node materials
function applyNodeHeatColor(nodeId) {
  const node = currentGraphData.nodes.find(n => n.id === nodeId);
  if (!node || !node.__threeObj) return;

  const heatState = nodeHeatMap.get(nodeId);
  if (!heatState) return;

  // Skip if node is currently flashing (flash animation takes priority)
  if (flashingNodes.has(nodeId)) return;

  const threeObj = node.__threeObj;
  const materials = [];
  if (threeObj.material) materials.push(threeObj.material);
  if (threeObj.children) {
    threeObj.children.forEach(child => {
      if (child.material) materials.push(child.material);
    });
  }

  if (materials.length === 0) return;

  const heatColor = calculateHeatColor(nodeId, heatState.originalColor);
  materials.forEach(m => {
    m.color.setHex(heatColor);
  });
}
```

4. Modify addActivityEntry to register heat state when a file changes:
   - After creating the entry, before the return statement, add:
```javascript
  // Register heat state for this node
  if (entry.nodeId && entry.event !== 'deleted') {
    const node = currentGraphData.nodes.find(n => n.id === entry.nodeId);
    if (node && node.__threeObj) {
      const materials = [];
      if (node.__threeObj.material) materials.push(node.__threeObj.material);
      if (node.__threeObj.children) {
        node.__threeObj.children.forEach(child => {
          if (child.material) materials.push(child.material);
        });
      }

      // Store original color from first material
      const originalColor = materials.length > 0 ? materials[0].color.getHex() : 0xDDA0DD;

      nodeHeatMap.set(entry.nodeId, {
        lastChangeTime: Date.now(),
        originalColor: originalColor
      });
    }
  }
```

Important: Do NOT modify flashNodeWithType - flash animations should override heat temporarily, then heat continues after flash completes.
  </action>
  <verify>
Run `npm run build` in the project directory - should complete without errors. Check that nodeHeatMap, calculateHeatColor, and applyNodeHeatColor are defined in renderer.js.
  </verify>
  <done>
Heat state tracking (nodeHeatMap) stores lastChangeTime and originalColor per node. calculateHeatColor returns interpolated gradient color. applyNodeHeatColor updates node materials. addActivityEntry registers heat state on file changes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement continuous heat decay animation loop</name>
  <files>src/renderer/renderer.js</files>
  <action>
Add the heat decay animation loop that continuously updates all heated nodes:

1. Add heat loop state tracking near other animation state:
```javascript
// Heat decay animation loop
let heatLoopRunning = false;
let heatLoopRafId = null;
```

2. Add the main heat decay loop function:
```javascript
// Start the heat decay animation loop
function startHeatDecayLoop() {
  if (heatLoopRunning) return;
  heatLoopRunning = true;

  function heatLoop() {
    if (!heatLoopRunning) return;

    const now = Date.now();
    const nodesToRemove = [];

    // Update all heated nodes
    nodeHeatMap.forEach((heatState, nodeId) => {
      const elapsed = now - heatState.lastChangeTime;

      // Remove from heat map if fully cooled
      if (elapsed >= heatDecayDuration) {
        nodesToRemove.push(nodeId);
        // Restore original color
        const node = currentGraphData.nodes.find(n => n.id === nodeId);
        if (node && node.__threeObj && !flashingNodes.has(nodeId)) {
          const materials = [];
          if (node.__threeObj.material) materials.push(node.__threeObj.material);
          if (node.__threeObj.children) {
            node.__threeObj.children.forEach(child => {
              if (child.material) materials.push(child.material);
            });
          }
          materials.forEach(m => m.color.setHex(heatState.originalColor));
        }
      } else {
        // Apply current heat color
        applyNodeHeatColor(nodeId);
      }
    });

    // Clean up fully cooled nodes
    nodesToRemove.forEach(id => nodeHeatMap.delete(id));

    // Continue loop if there are still heated nodes
    if (nodeHeatMap.size > 0) {
      heatLoopRafId = requestAnimationFrame(heatLoop);
    } else {
      heatLoopRunning = false;
      heatLoopRafId = null;
    }
  }

  heatLoopRafId = requestAnimationFrame(heatLoop);
}

// Stop heat decay loop (for cleanup)
function stopHeatDecayLoop() {
  heatLoopRunning = false;
  if (heatLoopRafId) {
    cancelAnimationFrame(heatLoopRafId);
    heatLoopRafId = null;
  }
}
```

3. Modify the heat state registration in addActivityEntry to also start the loop:
   - After setting nodeHeatMap entry, add:
```javascript
      // Start heat decay loop if not already running
      startHeatDecayLoop();
```

4. Modify flashNodeWithType to restore heat color after flash completes (instead of original color):
   - In the flash animation's completion block (where it restores original colors), change:
```javascript
      // Restore original state (or leave faded for deleted)
      materials.forEach((material, i) => {
        // After flash, apply heat color if node is heated, else original
        const heatState = nodeHeatMap.get(nodeId);
        if (heatState && !isDelete) {
          material.color.setHex(calculateHeatColor(nodeId, originalColors[i]));
        } else {
          material.color.setHex(originalColors[i]);
        }
        if (!isDelete) {
          material.opacity = originalOpacities[i];
        }
      });
```

This ensures that when a flash animation ends, the node shows its current heat color (not the base color) if it's still heated.
  </action>
  <verify>
Run `npm run build` - should complete without errors. Run `npm start` and open a project. Edit a file in .planning/ or src/ - the node should:
1. Flash with the change type color (green/orange/red)
2. After flash completes, show hot red/orange color
3. Gradually transition through orange -> yellow -> normal color over ~5 minutes
  </verify>
  <done>
Heat decay animation loop runs continuously while nodes are heated. Loop updates all heated node colors each frame. Flash animation integrates with heat (flash first, then shows heat color). Nodes automatically clean up from heat map when fully cooled.
  </done>
</task>

</tasks>

<verification>
1. Build succeeds: `npm run build` completes without errors
2. Heat appears: Editing a file causes node to glow hot red after flash animation
3. Heat decays: Node color transitions smoothly red -> orange -> yellow -> normal over time
4. Multiple files: Editing multiple files shows multiple heated nodes simultaneously
5. Flash priority: Flash animation plays first, heat continues after flash ends
</verification>

<success_criteria>
- HET-01: Recently changed files display hot color (red/orange glow) - SATISFIED
- HET-02: File heat color cools down over time (red -> orange -> yellow -> normal) - SATISFIED
- Heat state persists across flash animations
- No performance issues with multiple heated nodes
</success_criteria>

<output>
After completion, create `.planning/phases/09-heat-map-visualization/09-01-SUMMARY.md`
</output>

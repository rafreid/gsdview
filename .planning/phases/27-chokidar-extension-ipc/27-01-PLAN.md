---
phase: 27-chokidar-extension-ipc
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/main/main.js
  - src/main/preload.js
autonomous: true

must_haves:
  truths:
    - "Chokidar detects new event files in .gsd-viewer/events/ directory"
    - "Event JSON is parsed and validated before forwarding"
    - "Duplicate events (same file_path within 200ms) are ignored"
    - "Events are enriched with graph node ID before forwarding"
    - "Events arrive at renderer in order via IPC"
    - "Event files are deleted after processing"
  artifacts:
    - path: "src/main/main.js"
      provides: "Event watcher, deduplication, enrichment, queue, IPC forwarding"
      contains: ".gsd-viewer/events"
    - path: "src/main/preload.js"
      provides: "onClaudeOperation listener for renderer"
      contains: "claude-operation"
  key_links:
    - from: "src/main/main.js"
      to: "renderer"
      via: "mainWindow.webContents.send('claude-operation')"
      pattern: "send.*claude-operation"
    - from: "src/main/preload.js"
      to: "renderer code"
      via: "onClaudeOperation callback exposure"
      pattern: "onClaudeOperation"
---

<objective>
Extend Electron's main process to watch for Claude Code operation events and forward them to the renderer.

Purpose: Enable real-time visualization of Claude file operations (read/write/edit) that are invisible to the existing file watcher (which only sees file system changes).

Output: Complete event pipeline from hook-generated files to renderer-ready IPC messages.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/26-hook-infrastructure/26-01-SUMMARY.md

Key handoff from Phase 26:
- Event files at `.gsd-viewer/events/{timestamp}-{operation}-{hash}.json`
- Schema v1.0: { schema_version, timestamp, operation, file_path, tool, source }
- Files need cleanup after processing
- Deduplication needed: hooks can fire twice (200ms window)

Existing patterns (from STATE.md decisions):
- Node IDs prefixed with sourceType: `planning:/path` or `src:/path`
- File watcher uses chokidar with debouncing
- IPC events use descriptive names like 'file-change'
</context>

<tasks>

<task type="auto">
  <name>Task 1: Claude Event Watcher</name>
  <files>src/main/main.js</files>
  <action>
Add a separate chokidar watcher for Claude operation events. This must be independent from the existing file watcher.

1. Add new module-level variables:
   ```javascript
   let claudeEventWatcher = null;
   const recentEvents = new Map(); // For deduplication: file_path -> timestamp
   const eventQueue = [];          // Serial processing queue
   let isProcessingQueue = false;  // Queue lock
   const DEDUP_WINDOW_MS = 200;    // Timestamp window for deduplication
   ```

2. Create `startClaudeEventWatcher(projectPath)` function:
   - Watch `path.join(projectPath, '.gsd-viewer', 'events')` directory
   - Use chokidar options: `{ ignoreInitial: true, persistent: true, depth: 0 }`
   - On 'add' event: call `handleClaudeEvent(filePath)`
   - Log: `[ClaudeEvents] Watching: {path}`

3. Create `stopClaudeEventWatcher()` function:
   - Close watcher if exists
   - Clear recentEvents Map
   - Clear eventQueue array
   - Reset isProcessingQueue flag

4. Update `startWatching(projectPath)` to also call `startClaudeEventWatcher(projectPath)`

5. Update `stopWatching()` to also call `stopClaudeEventWatcher()`

Important: Do NOT debounce Claude events (unlike file-change events). Each event file represents a distinct operation.
  </action>
  <verify>
Application starts without errors. Console shows "[ClaudeEvents] Watching:" log when project loads.
  </verify>
  <done>
Chokidar watches .gsd-viewer/events/ and triggers handleClaudeEvent on new files.
  </done>
</task>

<task type="auto">
  <name>Task 2: Event Processing Pipeline</name>
  <files>src/main/main.js</files>
  <action>
Implement the complete event processing pipeline: parse, deduplicate, enrich, queue, forward, cleanup.

1. Create `handleClaudeEvent(eventFilePath)` function:
   ```javascript
   async function handleClaudeEvent(eventFilePath) {
     try {
       // 1. Parse event file
       const content = fs.readFileSync(eventFilePath, 'utf-8');
       const event = JSON.parse(content);

       // 2. Validate required fields
       if (!event.file_path || !event.operation || !event.timestamp) {
         console.error('[ClaudeEvents] Invalid event - missing fields:', eventFilePath);
         fs.unlinkSync(eventFilePath); // Cleanup invalid file
         return;
       }

       // 3. Deduplication check
       const lastTimestamp = recentEvents.get(event.file_path);
       if (lastTimestamp && (event.timestamp - lastTimestamp) < DEDUP_WINDOW_MS) {
         console.log('[ClaudeEvents] Duplicate ignored:', event.file_path);
         fs.unlinkSync(eventFilePath); // Cleanup duplicate
         return;
       }
       recentEvents.set(event.file_path, event.timestamp);

       // 4. Clean up old entries from recentEvents (prevent memory leak)
       const cutoff = Date.now() - 60000; // 1 minute
       for (const [path, ts] of recentEvents.entries()) {
         if (ts < cutoff) recentEvents.delete(path);
       }

       // 5. Add to queue for serial processing
       eventQueue.push({ event, eventFilePath });
       processEventQueue();

     } catch (err) {
       console.error('[ClaudeEvents] Error processing event:', err.message);
       // Still try to cleanup the file
       try { fs.unlinkSync(eventFilePath); } catch (e) {}
     }
   }
   ```

2. Create `processEventQueue()` function for serial processing:
   ```javascript
   async function processEventQueue() {
     if (isProcessingQueue || eventQueue.length === 0) return;

     isProcessingQueue = true;

     while (eventQueue.length > 0) {
       const { event, eventFilePath } = eventQueue.shift();

       // Enrich with node ID
       const enrichedEvent = enrichEventWithNodeId(event);

       // Forward to renderer
       if (mainWindow && !mainWindow.isDestroyed()) {
         mainWindow.webContents.send('claude-operation', enrichedEvent);
         console.log('[ClaudeEvents] Forwarded:', enrichedEvent.operation, enrichedEvent.nodeId || event.file_path);
       }

       // Cleanup event file
       try {
         fs.unlinkSync(eventFilePath);
       } catch (err) {
         console.error('[ClaudeEvents] Cleanup failed:', eventFilePath);
       }
     }

     isProcessingQueue = false;
   }
   ```

3. Create `enrichEventWithNodeId(event)` function:
   ```javascript
   function enrichEventWithNodeId(event) {
     // Determine sourceType from file path
     let sourceType = 'unknown';
     let relativePath = event.file_path;

     // Check if path contains .planning/ or src/
     if (event.file_path.includes('/.planning/') || event.file_path.includes('\\.planning\\')) {
       sourceType = 'planning';
       // Extract relative path from .planning/
       const match = event.file_path.match(/\.planning[\/\\](.+)$/);
       if (match) relativePath = match[1];
     } else if (event.file_path.includes('/src/') || event.file_path.includes('\\src\\')) {
       sourceType = 'src';
       // Extract relative path from src/
       const match = event.file_path.match(/src[\/\\](.+)$/);
       if (match) relativePath = match[1];
     }

     // Build node ID matching graph-builder.js pattern
     // Format: sourceType:/relative/path
     const nodeId = sourceType !== 'unknown'
       ? `${sourceType}:/${relativePath.replace(/\\/g, '/')}`
       : null;

     return {
       ...event,
       nodeId,
       sourceType
     };
   }
   ```

Important implementation notes:
- Use synchronous file operations (readFileSync, unlinkSync) since events are small JSON files
- Log all operations with [ClaudeEvents] prefix for debugging
- Always cleanup event files, even on parse errors
- Queue ensures events maintain order even if multiple arrive simultaneously
  </action>
  <verify>
Manually test by creating an event file:
```bash
echo '{"schema_version":"1.0","timestamp":'$(date +%s%3N)',"operation":"read","file_path":"/home/rafreid/AFLUXSYS/products/GSDv/src/main/main.js","tool":"Read","source":"claude-code"}' > .gsd-viewer/events/test-read-123.json
```
Console should show "[ClaudeEvents] Forwarded: read src://main/main.js" and file should be deleted.
  </verify>
  <done>
Events are parsed, deduplicated, enriched with nodeId, forwarded via IPC, and cleaned up.
  </done>
</task>

<task type="auto">
  <name>Task 3: Preload IPC Listener</name>
  <files>src/main/preload.js</files>
  <action>
Add the onClaudeOperation listener to expose Claude events to renderer.

Add to the `electronAPI` object in contextBridge.exposeInMainWorld():

```javascript
onClaudeOperation: (callback) => ipcRenderer.on('claude-operation', (event, data) => callback(data))
```

This follows the exact same pattern as the existing `onFilesChanged` listener.

The renderer will later use this as:
```javascript
window.electronAPI.onClaudeOperation((event) => {
  // event.operation: 'read' | 'write' | 'edit'
  // event.nodeId: 'src:/main/main.js' or 'planning:/STATE.md'
  // event.file_path: absolute path
  // event.timestamp: Unix ms
  // event.source: 'claude-code'
});
```
  </action>
  <verify>
In DevTools console, verify the API is exposed:
```javascript
typeof window.electronAPI.onClaudeOperation === 'function'
// Should return true
```
  </verify>
  <done>
Renderer can subscribe to Claude operation events via window.electronAPI.onClaudeOperation().
  </done>
</task>

</tasks>

<verification>
## End-to-End Test

1. Start the application and load a project

2. Create a test event file manually:
   ```bash
   cd /home/rafreid/AFLUXSYS/products/GSDv
   TS=$(date +%s%3N)
   echo '{"schema_version":"1.0","timestamp":'$TS',"operation":"write","file_path":"/home/rafreid/AFLUXSYS/products/GSDv/src/main/main.js","tool":"Write","source":"claude-code"}' > .gsd-viewer/events/${TS}-write-test123.json
   ```

3. Verify in console:
   - `[ClaudeEvents] Forwarded: write src:/main/main.js`

4. Verify file was deleted:
   ```bash
   ls .gsd-viewer/events/
   # Should be empty (only .gitkeep)
   ```

5. Test deduplication - create two events <200ms apart:
   ```bash
   TS=$(date +%s%3N)
   echo '{"schema_version":"1.0","timestamp":'$TS',"operation":"read","file_path":"/test.txt","tool":"Read","source":"claude-code"}' > .gsd-viewer/events/${TS}-read-a.json
   echo '{"schema_version":"1.0","timestamp":'$((TS+50))',"operation":"read","file_path":"/test.txt","tool":"Read","source":"claude-code"}' > .gsd-viewer/events/${TS}-read-b.json
   ```
   - First event should be forwarded
   - Second event should show "Duplicate ignored" log
   - Both files should be cleaned up

6. In DevTools console:
   ```javascript
   window.electronAPI.onClaudeOperation((e) => console.log('GOT:', e));
   ```
   Then create another event file - should see "GOT:" log with event data.
</verification>

<success_criteria>
1. Application starts and shows "[ClaudeEvents] Watching:" in console
2. New event files in .gsd-viewer/events/ trigger processing
3. Events are enriched with nodeId matching graph node format
4. Duplicate events (same file_path within 200ms) are ignored
5. IPC channel 'claude-operation' delivers events to renderer
6. Event files are deleted after processing
7. window.electronAPI.onClaudeOperation is available to renderer
</success_criteria>

<output>
After completion, create `.planning/phases/27-chokidar-extension-ipc/27-01-SUMMARY.md`
</output>

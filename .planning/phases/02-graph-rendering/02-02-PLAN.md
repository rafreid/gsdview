---
phase: 02-graph-rendering
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/renderer/renderer.js
autonomous: true

must_haves:
  truths:
    - "Nodes with more connections appear larger than isolated nodes"
    - "Root/project node is largest (most connections)"
    - "Leaf nodes (no children) are smallest"
    - "Size difference is noticeable but not extreme"
  artifacts:
    - path: "src/renderer/renderer.js"
      provides: "Dynamic node sizing based on connection count"
      contains: "nodeVal"
  key_links:
    - from: "graphData links"
      to: "node size calculation"
      via: "connection counting function"
      pattern: "\\.nodeVal\\("
---

<objective>
Implement dynamic node sizing based on connection count to visually emphasize important/central nodes.

Purpose: Users can identify important nodes (hubs with many connections) at a glance without reading labels.
Output: Nodes scale proportionally to their connection count in the graph.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@src/renderer/renderer.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Calculate node connection counts</name>
  <files>src/renderer/renderer.js</files>
  <action>
Create a function to calculate connection counts for each node based on the graph's links array.

Implementation:
1. Create function `calculateConnectionCounts(graphData)` that:
   - Takes graphData object with nodes and links arrays
   - Creates a Map of nodeId -> connectionCount
   - Iterates through links, incrementing count for both source and target
   - Returns the Map

2. Call this function after defining placeholderData and store the result

3. Configure the graph to use `.nodeVal()` method with a callback that:
   - Looks up the node's connection count from the Map
   - Returns a size value based on count
   - Use formula: baseSize + (connectionCount * scaleFactor)
   - Suggested values: baseSize = 2, scaleFactor = 1.5
   - This gives isolated nodes size 2, and well-connected nodes progressively larger

4. Remove or adjust the static `.nodeRelSize(6)` call since `.nodeVal()` provides dynamic sizing

Note: The nodeVal determines the node's volume/mass in the physics simulation and its visual size. Higher values = larger spheres.
  </action>
  <verify>
1. Run `npm start`
2. Observe the graph - root/project node should be largest
3. Phase nodes should be medium-large (connected to project and plans)
4. Plan nodes should be medium (connected to phase)
5. Requirement nodes should be medium (connected to phases)
6. Verify size differences are noticeable but not extreme
  </verify>
  <done>
calculateConnectionCounts function exists and is used. Nodes display with sizes proportional to their connection counts.
  </done>
</task>

<task type="auto">
  <name>Task 2: Fine-tune sizing parameters</name>
  <files>src/renderer/renderer.js</files>
  <action>
After initial implementation, adjust sizing parameters for optimal visual balance:

1. Test with current placeholder data and observe the size distribution
2. Adjust baseSize and scaleFactor if needed:
   - If all nodes look too similar: increase scaleFactor
   - If hub nodes are too dominant: decrease scaleFactor
   - If isolated nodes are too small: increase baseSize

3. Add nodeRelSize() back if needed to control overall scale:
   - nodeRelSize sets the base unit size
   - nodeVal multiplies against this base
   - Typical setup: `.nodeRelSize(4).nodeVal(node => getNodeSize(node))`

4. Ensure minimum visible size:
   - No node should be so small it's hard to click/see
   - Add a minimum value check: `Math.max(minSize, calculatedSize)`
   - Suggested minSize: 2

5. Add comments explaining the sizing logic for future maintainers
  </action>
  <verify>
1. Run `npm start`
2. Verify all nodes are clickable/visible (none too small)
3. Verify size hierarchy: root > phases > plans/requirements
4. Verify the graph physics still work well (nodes don't overlap excessively)
  </verify>
  <done>
Node sizing is visually balanced. Size hierarchy is clear. All nodes remain interactive. Code is commented.
  </done>
</task>

</tasks>

<verification>
- [ ] App launches without errors
- [ ] Node sizes vary based on connection count
- [ ] Root/hub nodes are visibly larger than leaf nodes
- [ ] Size differences are clear but not overwhelming
- [ ] All nodes remain visible and clickable
- [ ] GRF-03 requirement is satisfied
</verification>

<success_criteria>
Nodes with more connections appear larger than isolated nodes. The size difference is immediately noticeable when viewing the graph.
</success_criteria>

<output>
After completion, create `.planning/phases/02-graph-rendering/02-02-SUMMARY.md`
</output>

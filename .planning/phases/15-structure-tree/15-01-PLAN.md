---
phase: 15-structure-tree
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/renderer/renderer.js
autonomous: true

must_haves:
  truths:
    - "Markdown files return array of structure items with headers, lists, code blocks"
    - "JS/TS files return array of structure items with functions, classes, imports, exports"
    - "JSON/YAML files return array of structure items with nested key paths"
  artifacts:
    - path: "src/renderer/renderer.js"
      provides: "parseFileStructure function"
      contains: "parseMarkdownStructure"
    - path: "src/renderer/renderer.js"
      provides: "parseCodeStructure function"
      contains: "parseCodeStructure"
    - path: "src/renderer/renderer.js"
      provides: "parseConfigStructure function"
      contains: "parseConfigStructure"
  key_links:
    - from: "parseFileStructure"
      to: "file content"
      via: "file extension detection"
      pattern: "\\.(md|js|ts|json|yaml|yml)"
---

<objective>
Create file structure parsing functions that extract navigable elements from markdown, code, and config files.

Purpose: Enable users to see file structure (headers, functions, classes, keys) in the inspector modal
Output: parseFileStructure() function that returns structured items with line numbers for navigation
</objective>

<execution_context>
@/home/rafreid/.claude/get-shit-done/workflows/execute-plan.md
@/home/rafreid/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@src/renderer/renderer.js (patterns: applySyntaxHighlighting, populateInspectorDiff)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add file structure parsing functions</name>
  <files>src/renderer/renderer.js</files>
  <action>
Add parsing functions after the applySyntaxHighlighting function (around line 1820):

1. **parseFileStructure(content, filename)** - Main entry point
   - Detect file type by extension
   - Route to appropriate parser
   - Return array of structure items: { type, name, line, depth, children? }

2. **parseMarkdownStructure(content)** - For .md files
   - Extract headers (H1-H6): Match lines starting with 1-6 `#` characters
   - Extract list items: Match lines starting with `-`, `*`, or numbered `1.`
   - Extract code block boundaries: Match lines starting with ``` (with optional language)
   - Track line numbers for each item
   - Return: [{ type: 'header'|'list'|'codeblock', name: string, line: number, depth: number }]
   - depth: 1-6 for headers based on # count, indent level for lists

3. **parseCodeStructure(content)** - For .js, .ts, .jsx, .tsx files
   - Extract function declarations: `function name(`, `async function name(`
   - Extract arrow functions with names: `const name = (` or `const name = async (`
   - Extract class declarations: `class Name`
   - Extract import statements: `import ... from`
   - Extract export statements: `export default`, `export const`, `export function`
   - Track line numbers for each item
   - Return: [{ type: 'function'|'class'|'import'|'export', name: string, line: number, depth: number }]
   - depth: 0 for top-level, 1 for class methods (inside class)

4. **parseConfigStructure(content, filename)** - For .json, .yaml, .yml files
   - For JSON: Parse and recursively extract key paths with line number estimation
   - For YAML: Extract keys by detecting lines with `key:` pattern and indentation
   - Track nesting depth by indentation
   - Return: [{ type: 'key', name: string, line: number, depth: number }]

Important implementation notes:
- Split content by newlines once, then iterate with line index
- Use regex patterns similar to applySyntaxHighlighting for consistency
- Handle edge cases: empty files, binary files (return empty array)
- For JSON, line estimation uses indexOf for key position (not perfect but functional)
- For YAML, indent depth = leading spaces / 2
  </action>
  <verify>
Add temporary test in renderer.js after the function definitions:
```javascript
// Test parseFileStructure (remove after verification)
console.log('[Structure] Test MD:', parseFileStructure('# H1\n## H2\n- item\n```js\ncode\n```', 'test.md'));
console.log('[Structure] Test JS:', parseFileStructure('import x from "y";\nfunction foo() {}\nclass Bar {}', 'test.js'));
console.log('[Structure] Test JSON:', parseFileStructure('{"a": {"b": 1}}', 'test.json'));
```
Run `npm start` and check DevTools console for structure arrays with correct types and line numbers.
  </verify>
  <done>
parseFileStructure returns arrays with:
- MD: headers with depth 1-6, list items, code blocks with line numbers
- JS/TS: functions, classes, imports, exports with line numbers
- JSON/YAML: nested keys with depth levels and line numbers
  </done>
</task>

</tasks>

<verification>
1. Open app with `npm start`
2. Check DevTools console for test output
3. Verify MD structure has headers at correct depth, lists, code blocks
4. Verify JS structure has functions, classes, imports, exports
5. Verify JSON structure has nested keys with depth values
6. Remove test code after verification
</verification>

<success_criteria>
- parseFileStructure exists and routes by file extension
- parseMarkdownStructure extracts headers (H1-H6), lists, code blocks
- parseCodeStructure extracts functions, classes, imports, exports
- parseConfigStructure extracts JSON/YAML key structure
- All items include line numbers for navigation
- No runtime errors in DevTools
</success_criteria>

<output>
After completion, create `.planning/phases/15-structure-tree/15-01-SUMMARY.md`
</output>

---
phase: 03-gsd-parsing
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/main/parsers/requirements-parser.js
  - src/main/main.js
  - src/main/preload.js
autonomous: true
 
must_haves:
  truths:
    - "REQUIREMENTS.md is parsed into structured requirement data"
    - "Requirements are linked to their mapped phases"
    - "IPC channel exposes parsed requirements to renderer"
  artifacts:
    - path: "src/main/parsers/requirements-parser.js"
      provides: "parseRequirements function"
      exports: ["parseRequirements"]
    - path: "src/main/main.js"
      provides: "IPC handler for parse-requirements"
      contains: "ipcMain.handle('parse-requirements'"
    - path: "src/main/preload.js"
      provides: "parseRequirements API exposed to renderer"
      contains: "parseRequirements"
  key_links:
    - from: "src/main/main.js"
      to: "src/main/parsers/requirements-parser.js"
      via: "require and call parseRequirements"
      pattern: "require.*requirements-parser"
---

<objective>
Parse REQUIREMENTS.md to extract requirements and their phase mappings.

Purpose: Requirements are a key node type in the GSD Viewer graph. The traceability table in REQUIREMENTS.md shows which requirements map to which phases, enabling edges between requirement nodes and phase nodes.

Output: A parser module that reads REQUIREMENTS.md and returns structured data with requirements, their statuses, and phase mappings. IPC channel to expose this to the renderer.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/REQUIREMENTS.md
@src/main/main.js
@src/main/preload.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create requirements parser module</name>
  <files>src/main/parsers/requirements-parser.js</files>
  <action>
Create `src/main/parsers/requirements-parser.js`.

The parser should:
1. Accept a path to a .planning/ folder
2. Read `.planning/REQUIREMENTS.md` using Node.js fs
3. Parse the markdown to extract:
   - Each requirement (from `- [ ] **REQ-ID**:` or `- [x] **REQ-ID**:` patterns)
   - Requirement description (text after the ID)
   - Status (from checkbox: [x] = complete, [ ] = pending)
   - Category (from section headers like `### Graph Core`, `### Navigation`)
4. Parse the Traceability table to get phase mappings:
   - Find `## Traceability` section
   - Extract rows: `| REQ-ID | Phase N | Status |`
   - Map each requirement to its phase number
5. Return structured data:
```javascript
{
  requirements: [
    {
      id: 'GRF-01',
      description: 'Graph renders as 3D force-directed layout...',
      category: 'Graph Core',
      status: 'pending', // 'complete' | 'pending'
      phaseNumber: 1  // from traceability table
    },
    ...
  ]
}
```

Use regex-based parsing. The format is consistent:
- Requirements: `- [ ] **ID**: description` or `- [x] **ID**: description`
- Traceability: markdown table with `| Requirement | Phase | Status |`

Export: `module.exports = { parseRequirements };`
  </action>
  <verify>
```bash
cd /home/rafreid/AFLUXSYS/products/GSDv
node -e "const {parseRequirements} = require('./src/main/parsers/requirements-parser'); console.log(JSON.stringify(parseRequirements('.planning'), null, 2));"
```
Should output JSON with ~24 requirements, each with id, description, category, status, and phaseNumber.
  </verify>
  <done>
parseRequirements('.planning') returns object with requirements array containing all v1 requirements, each with id, description, category, status, and phaseNumber from traceability mapping.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add IPC handler and preload API</name>
  <files>src/main/main.js, src/main/preload.js</files>
  <action>
In `src/main/main.js`:
1. Add require: `const { parseRequirements } = require('./parsers/requirements-parser');`
2. Add IPC handler inside `app.whenReady()`:
```javascript
ipcMain.handle('parse-requirements', async (event, planningPath) => {
  try {
    return parseRequirements(planningPath);
  } catch (error) {
    console.error('Error parsing requirements:', error);
    return { error: error.message, requirements: [] };
  }
});
```

In `src/main/preload.js`:
Update the exposed API (add to existing object):
```javascript
contextBridge.exposeInMainWorld('electronAPI', {
  selectFolder: () => ipcRenderer.invoke('select-folder'),
  parseRoadmap: (planningPath) => ipcRenderer.invoke('parse-roadmap', planningPath),
  parseRequirements: (planningPath) => ipcRenderer.invoke('parse-requirements', planningPath)
});
```

Note: If 03-01 hasn't run yet, include the parseRoadmap line too. If it has, just add parseRequirements.
  </action>
  <verify>
```bash
npm start
# In DevTools console:
# const result = await window.electronAPI.parseRequirements('/home/rafreid/AFLUXSYS/products/GSDv/.planning');
# console.log(result.requirements.length); // Should be ~24
# console.log(result.requirements.find(r => r.id === 'STR-01')); // Should show phaseNumber: 3
```
  </verify>
  <done>
IPC channel 'parse-requirements' registered, preload exposes `electronAPI.parseRequirements()`, calling it returns parsed requirements with phase mappings.
  </done>
</task>

</tasks>

<verification>
1. Parser module exists at src/main/parsers/requirements-parser.js
2. Running parser directly outputs valid JSON with requirements
3. Each requirement has phaseNumber from traceability table
4. IPC handler registered in main.js
5. API exposed in preload.js
6. Can call from renderer DevTools and get real data
</verification>

<success_criteria>
- parseRequirements function parses all v1 requirements from REQUIREMENTS.md
- Each requirement has: id, description, category, status, phaseNumber
- Phase mappings come from Traceability table (not hardcoded)
- IPC channel works end-to-end
- Error handling returns empty requirements array on failure
</success_criteria>

<output>
After completion, create `.planning/phases/03-gsd-parsing/03-02-SUMMARY.md`
</output>

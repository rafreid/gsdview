---
phase: 03-gsd-parsing
plan: 04
type: execute
wave: 2
depends_on: ["03-01", "03-02", "03-03"]
files_modified:
  - src/main/graph-builder.js
  - src/main/main.js
  - src/main/preload.js
  - src/renderer/renderer.js
autonomous: false

must_haves:
  truths:
    - "Graph shows real GSD data instead of placeholders"
    - "Phase nodes connect to Plan nodes"
    - "Requirement nodes connect to Phase nodes"
    - "File nodes connect to their parent folders"
    - "User can select a folder and see its .planning/ structure visualized"
  artifacts:
    - path: "src/main/graph-builder.js"
      provides: "buildGraph function that combines all parsers"
      exports: ["buildGraph"]
    - path: "src/renderer/renderer.js"
      provides: "Integration with IPC to load real data"
      contains: "electronAPI.buildGraph"
  key_links:
    - from: "src/main/graph-builder.js"
      to: "src/main/parsers/roadmap-parser.js"
      via: "require and use parsed data"
      pattern: "require.*roadmap-parser"
    - from: "src/main/graph-builder.js"
      to: "src/main/parsers/requirements-parser.js"
      via: "require and use parsed data"
      pattern: "require.*requirements-parser"
    - from: "src/main/graph-builder.js"
      to: "src/main/parsers/directory-parser.js"
      via: "require and use parsed data"
      pattern: "require.*directory-parser"
    - from: "src/renderer/renderer.js"
      to: "electronAPI.buildGraph"
      via: "IPC call on folder selection"
      pattern: "buildGraph.*selectedProjectPath"
---

<objective>
Build the complete graph from parsed data and integrate with the renderer.

Purpose: This plan combines all three parsers into a unified graph builder that produces nodes and links in the format expected by 3d-force-graph. It also wires the renderer to call this when a folder is selected, replacing placeholder data with real GSD structure.

Output: A graph-builder module that combines roadmap, requirements, and directory data into a complete graph. Renderer integration that loads real data when user selects a project folder.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@src/main/main.js
@src/main/preload.js
@src/renderer/renderer.js
@src/main/parsers/roadmap-parser.js (from 03-01)
@src/main/parsers/requirements-parser.js (from 03-02)
@src/main/parsers/directory-parser.js (from 03-03)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create graph builder module</name>
  <files>src/main/graph-builder.js</files>
  <action>
Create `src/main/graph-builder.js`.

The builder should:
1. Import all three parsers
2. Accept a project path (folder containing .planning/)
3. Call all parsers and combine results into graph format:

```javascript
const { parseRoadmap } = require('./parsers/roadmap-parser');
const { parseRequirements } = require('./parsers/requirements-parser');
const { parseDirectory } = require('./parsers/directory-parser');
const path = require('path');

function buildGraph(projectPath) {
  const planningPath = path.join(projectPath, '.planning');

  const roadmapData = parseRoadmap(planningPath);
  const requirementsData = parseRequirements(planningPath);
  const directoryData = parseDirectory(planningPath);

  const nodes = [];
  const links = [];

  // Root project node
  nodes.push({
    id: 'project-root',
    name: path.basename(projectPath),
    type: 'root'
  });

  // Phase nodes (from roadmap)
  roadmapData.phases.forEach(phase => {
    nodes.push({
      id: `phase-${phase.number}`,
      name: phase.name,
      type: 'phase',
      status: phase.status,
      goal: phase.goal
    });
    // Link: project -> phase
    links.push({
      source: 'project-root',
      target: `phase-${phase.number}`
    });

    // Plan nodes (from roadmap phase plans)
    phase.plans.forEach(plan => {
      nodes.push({
        id: `plan-${plan.id}`,
        name: plan.name,
        type: 'plan',
        description: plan.description
      });
      // Link: phase -> plan
      links.push({
        source: `phase-${phase.number}`,
        target: `plan-${plan.id}`
      });
    });
  });

  // Requirement nodes
  requirementsData.requirements.forEach(req => {
    nodes.push({
      id: `req-${req.id}`,
      name: req.id,
      type: 'requirement',
      description: req.description,
      category: req.category,
      status: req.status
    });
    // Link: requirement -> phase (from traceability)
    if (req.phaseNumber) {
      links.push({
        source: `req-${req.id}`,
        target: `phase-${req.phaseNumber}`
      });
    }
  });

  // File nodes (from directory)
  directoryData.items.forEach(item => {
    nodes.push({
      id: item.id,
      name: item.name,
      type: 'file',
      subtype: item.subtype,
      path: item.path
    });
    // Link: file -> parent folder
    if (item.parentId) {
      links.push({
        source: item.parentId,
        target: item.id
      });
    }
  });

  // Link root folder to project
  const rootFolder = directoryData.items.find(i => i.parentId === null);
  if (rootFolder) {
    links.push({
      source: 'project-root',
      target: rootFolder.id
    });
  }

  return { nodes, links };
}

module.exports = { buildGraph };
```

This produces the exact format that 3d-force-graph expects.
  </action>
  <verify>
```bash
cd /home/rafreid/AFLUXSYS/products/GSDv
node -e "const {buildGraph} = require('./src/main/graph-builder'); const result = buildGraph('.'); console.log('Nodes:', result.nodes.length, 'Links:', result.links.length); console.log(result.nodes.filter(n => n.type === 'phase').map(n => n.name));"
```
Should show node/link counts and list phase names.
  </verify>
  <done>
buildGraph(projectPath) combines all parsers and returns {nodes, links} in 3d-force-graph format with phases, plans, requirements, and files all connected.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add IPC handler and update preload</name>
  <files>src/main/main.js, src/main/preload.js</files>
  <action>
In `src/main/main.js`:
1. Add require at top: `const { buildGraph } = require('./graph-builder');`
2. Add IPC handler inside `app.whenReady()`:
```javascript
ipcMain.handle('build-graph', async (event, projectPath) => {
  try {
    return buildGraph(projectPath);
  } catch (error) {
    console.error('Error building graph:', error);
    return { error: error.message, nodes: [], links: [] };
  }
});
```

In `src/main/preload.js`:
Add buildGraph to the exposed API:
```javascript
contextBridge.exposeInMainWorld('electronAPI', {
  selectFolder: () => ipcRenderer.invoke('select-folder'),
  parseRoadmap: (planningPath) => ipcRenderer.invoke('parse-roadmap', planningPath),
  parseRequirements: (planningPath) => ipcRenderer.invoke('parse-requirements', planningPath),
  parseDirectory: (planningPath) => ipcRenderer.invoke('parse-directory', planningPath),
  buildGraph: (projectPath) => ipcRenderer.invoke('build-graph', projectPath)
});
```
  </action>
  <verify>
```bash
npm start
# In DevTools console:
# const result = await window.electronAPI.buildGraph('/home/rafreid/AFLUXSYS/products/GSDv');
# console.log('Nodes:', result.nodes.length, 'Links:', result.links.length);
```
  </verify>
  <done>
IPC channel 'build-graph' registered, preload exposes `electronAPI.buildGraph()`, returns combined graph data.
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate with renderer to load real data</name>
  <files>src/renderer/renderer.js</files>
  <action>
Update `src/renderer/renderer.js` to:
1. Keep placeholderData as fallback (for when no project selected)
2. Update the folder selection handler to call buildGraph and update the graph:

Find the existing folder selection handler and replace with:
```javascript
// Store selected project path
let selectedProjectPath = null;
let currentGraphData = placeholderData;

// Function to update graph with new data
function updateGraph(graphData) {
  currentGraphData = graphData;
  const connectionCounts = calculateConnectionCounts(graphData);

  Graph
    .graphData(graphData)
    .nodeVal(node => getNodeSize(node, connectionCounts));
}

// Folder selection handler
document.getElementById('select-folder-btn').addEventListener('click', async () => {
  if (window.electronAPI && window.electronAPI.selectFolder) {
    const folderPath = await window.electronAPI.selectFolder();
    if (folderPath) {
      selectedProjectPath = folderPath;
      document.getElementById('selected-path').textContent = folderPath;
      console.log('Selected folder:', folderPath);

      // Load real GSD data
      if (window.electronAPI.buildGraph) {
        const graphData = await window.electronAPI.buildGraph(folderPath);
        if (graphData.nodes && graphData.nodes.length > 0) {
          console.log('Loaded graph with', graphData.nodes.length, 'nodes and', graphData.links.length, 'links');
          updateGraph(graphData);
        } else if (graphData.error) {
          console.error('Error loading graph:', graphData.error);
        }
      }
    }
  } else {
    console.warn('electronAPI.selectFolder not available');
  }
});
```

Also update getLinkColor and getLinkWidth to work with currentGraphData instead of placeholderData:
- Change `placeholderData.nodes.find(...)` to `currentGraphData.nodes.find(...)`

The node color logic already uses the node parameter so it should work with new node types automatically. The existing color palette already has colors for: root, phase, plan, task, requirement, file.
  </action>
  <verify>
1. Run `npm start`
2. Click "Select Project" and choose `/home/rafreid/AFLUXSYS/products/GSDv`
3. Graph should update to show real phases, plans, requirements, and files
4. Check console for "Loaded graph with X nodes and Y links"
  </verify>
  <done>
Selecting a project folder loads real GSD data and updates the 3D graph. Placeholder data only shown before folder selection.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete GSD parsing pipeline: ROADMAP.md parser, REQUIREMENTS.md parser, directory tree parser, graph builder, and renderer integration</what-built>
  <how-to-verify>
1. Run `npm start` in the GSDv project directory
2. Click "Select Project" button
3. Navigate to `/home/rafreid/AFLUXSYS/products/GSDv` (or any project with .planning/ folder)
4. Verify the graph updates to show:
   - A central "root" node (project name)
   - Phase nodes (Foundation, Graph Rendering, GSD Parsing, etc.)
   - Plan nodes connected to their phases
   - Requirement nodes connected to their mapped phases
   - File nodes showing .planning/ directory structure
5. Orbit/zoom the graph to explore the structure
6. Check the color legend matches what you see (root=coral, phase=teal, plan=blue, requirement=gold, file=plum)
  </how-to-verify>
  <resume-signal>Type "approved" if graph shows real GSD data, or describe any issues</resume-signal>
</task>

</tasks>

<verification>
1. graph-builder.js exists and combines all parsers
2. IPC handler 'build-graph' registered
3. Renderer calls buildGraph on folder selection
4. Graph updates with real data (not placeholder)
5. All four success criteria met:
   - Phase -> Plan hierarchy visible
   - Requirement -> Phase mapping visible
   - File -> Parent folder connections visible
   - .planning/ tree represented
</verification>

<success_criteria>
- Selecting a GSD project folder replaces placeholder with real data
- Phase nodes are visible and connected to project root
- Plan nodes connect to their parent phases
- Requirement nodes connect to their mapped phases
- File nodes show .planning/ directory structure
- All existing graph features (colors, sizing, arrows) work with real data
</success_criteria>

<output>
After completion, create `.planning/phases/03-gsd-parsing/03-04-SUMMARY.md`
</output>

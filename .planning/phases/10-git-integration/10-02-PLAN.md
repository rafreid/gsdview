---
phase: 10-git-integration
plan: 02
type: execute
wave: 2
depends_on: ["10-01"]
files_modified:
  - src/renderer/renderer.js
autonomous: true

must_haves:
  truths:
    - "File nodes show visual indicator for uncommitted changes"
    - "Staged files appear visually different from unstaged files"
    - "User can distinguish modified, staged, and clean files at a glance"
  artifacts:
    - path: "src/renderer/renderer.js"
      provides: "Git status visual indicators on nodes"
      contains: "gitStatus"
  key_links:
    - from: "src/renderer/renderer.js"
      to: "electronAPI.getGitStatus"
      via: "async call during project load"
      pattern: "getGitStatus"
---

<objective>
Add visual indicators to file nodes showing git status (uncommitted changes, staged files).

Purpose: GIT-01 and GIT-02 requirements - users need to see which files have uncommitted or staged changes directly in the graph.
Output: File nodes with visual git status indicators (border colors, badges, or glow effects).
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-git-integration/10-01-SUMMARY.md
@src/renderer/renderer.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Store and fetch git status data</name>
  <files>src/renderer/renderer.js</files>
  <action>
Add git status tracking and fetching:

1. Add git status state variable near other state variables (around line 83):
```javascript
// Git status state
let gitStatusData = { modified: [], staged: [], untracked: [] };
```

2. Create async function to fetch git status (near other helper functions):
```javascript
// Fetch git status for the current project
async function fetchGitStatus(projectPath) {
  if (!window.electronAPI || !window.electronAPI.getGitStatus) {
    console.log('[Git] Git API not available');
    return;
  }

  try {
    const result = await window.electronAPI.getGitStatus(projectPath);
    if (result && !result.error) {
      gitStatusData = {
        modified: result.modified || [],
        staged: result.staged || [],
        untracked: result.untracked || []
      };
      console.log('[Git] Status loaded:', gitStatusData);
    } else {
      gitStatusData = { modified: [], staged: [], untracked: [] };
      console.log('[Git] Not a git repo or error:', result?.error);
    }
  } catch (err) {
    console.error('[Git] Error fetching status:', err);
    gitStatusData = { modified: [], staged: [], untracked: [] };
  }
}
```

3. Call fetchGitStatus in loadProject function (after parseProject succeeds, around line 1145):
```javascript
// Fetch git status for the project
await fetchGitStatus(projectPath);
```

4. Also call fetchGitStatus after file changes are detected (in the onFilesChanged callback, after loadProject):
```javascript
// Refresh git status after file changes
await fetchGitStatus(selectedProjectPath);
```
  </action>
  <verify>
Run `npm run build && npm start`, select a git project, check DevTools console for "[Git] Status loaded:" message with actual git status data.
  </verify>
  <done>
Git status is fetched when project loads and when files change.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add git status visual indicators to file nodes</name>
  <files>src/renderer/renderer.js</files>
  <action>
Modify node rendering to show git status indicators:

1. Add helper function to check git status of a node (near getNodeColor function):
```javascript
// Get git status for a file node
function getNodeGitStatus(node) {
  if (node.type !== 'file' || !node.path) return null;

  // Normalize path for comparison (git uses forward slashes)
  const normalizedPath = node.path.replace(/\\/g, '/');

  // Build full relative path based on sourceType
  let fullRelativePath;
  if (node.sourceType === 'planning') {
    fullRelativePath = '.planning/' + normalizedPath;
  } else if (node.sourceType === 'src') {
    fullRelativePath = 'src/' + normalizedPath;
  } else {
    fullRelativePath = normalizedPath;
  }

  // Check staged first (takes priority)
  if (gitStatusData.staged.some(p => p.endsWith(normalizedPath) || p === fullRelativePath)) {
    return 'staged';
  }
  // Check modified (unstaged changes)
  if (gitStatusData.modified.some(p => p.endsWith(normalizedPath) || p === fullRelativePath)) {
    return 'modified';
  }
  // Check untracked
  if (gitStatusData.untracked.some(p => p.endsWith(normalizedPath) || p === fullRelativePath)) {
    return 'untracked';
  }

  return null;
}
```

2. Define git status indicator colors (near changeTypeColors):
```javascript
// Git status colors for node indicators
const gitStatusColors = {
  staged: 0x2ECC71,    // Green - ready to commit
  modified: 0xF39C12,  // Orange - uncommitted changes
  untracked: 0x9B59B6  // Purple - new untracked file
};
```

3. Modify nodeThreeObject function (around line 788) to add git status ring indicator for file nodes:

In the file node section (after creating the mesh and wireframe, before `return mesh`), add:
```javascript
// Add git status indicator ring if applicable
const gitStatus = getNodeGitStatus(node);
if (gitStatus && gitStatusColors[gitStatus]) {
  const ringGeometry = new THREE.RingGeometry(size * 1.1, size * 1.4, 16);
  const ringMaterial = new THREE.MeshBasicMaterial({
    color: gitStatusColors[gitStatus],
    transparent: true,
    opacity: 0.7,
    side: THREE.DoubleSide
  });
  const ring = new THREE.Mesh(ringGeometry, ringMaterial);

  // Store git status on the mesh for tooltip
  mesh.userData = mesh.userData || {};
  mesh.userData.gitStatus = gitStatus;

  mesh.add(ring);
}
```

4. Update the tooltip display (in onNodeHover, around line 900) to show git status:
After displaying the extension info, add:
```javascript
// Show git status in tooltip
const gitStatus = getNodeGitStatus(node);
if (gitStatus) {
  const statusColor = '#' + gitStatusColors[gitStatus].toString(16).padStart(6, '0');
  const statusLabel = gitStatus === 'staged' ? 'Staged' :
                      gitStatus === 'modified' ? 'Modified (uncommitted)' :
                      'Untracked';
  content += `<br><span style="color: ${statusColor}">Git: ${statusLabel}</span>`;
}
```
  </action>
  <verify>
1. Run `npm run build && npm start`
2. Select a project with uncommitted git changes
3. Verify file nodes with changes have colored rings:
   - Modified files: orange ring
   - Staged files: green ring
   - Untracked files: purple ring
4. Hover over a file with git changes - tooltip shows git status
  </verify>
  <done>
File nodes visually indicate their git status with colored rings, and tooltips show git status text.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add git status to color legend</name>
  <files>src/renderer/renderer.js</files>
  <action>
Update populateColorLegend function (around line 1191) to include git status section:

After the "File Types" section (before the closing of the function), add:

```javascript
// Git Status section
const gitTitle = document.createElement('div');
gitTitle.className = 'legend-title';
gitTitle.style.marginTop = '12px';
gitTitle.textContent = 'Git Status';
legendContent.appendChild(gitTitle);

const gitStatusLabels = {
  staged: 'Staged (ready to commit)',
  modified: 'Modified (uncommitted)',
  untracked: 'Untracked (new file)'
};

for (const [status, label] of Object.entries(gitStatusLabels)) {
  const item = document.createElement('div');
  item.className = 'legend-item';

  const colorCircle = document.createElement('div');
  colorCircle.className = 'legend-color';
  colorCircle.style.backgroundColor = '#' + gitStatusColors[status].toString(16).padStart(6, '0');

  const labelSpan = document.createElement('span');
  labelSpan.className = 'legend-label';
  labelSpan.textContent = label;

  item.appendChild(colorCircle);
  item.appendChild(labelSpan);
  legendContent.appendChild(item);
}
```
  </action>
  <verify>
Run `npm run build && npm start`, expand the color legend at bottom-left. Verify "Git Status" section appears with staged (green), modified (orange), and untracked (purple) entries.
  </verify>
  <done>
Color legend includes git status section explaining the ring indicator colors.
  </done>
</task>

</tasks>

<verification>
1. Run `npm run build && npm start`
2. Select a git repository with uncommitted changes
3. Verify:
   - Console shows "[Git] Status loaded:" with file arrays
   - Modified files have orange rings around them
   - Staged files have green rings
   - Untracked files have purple rings
   - Hovering shows "Git: Modified (uncommitted)" etc in tooltip
   - Color legend has "Git Status" section
4. Make a change to a file (e.g., add whitespace), verify ring appears after refresh
5. Stage a file (`git add filename`), verify ring changes from orange to green
</verification>

<success_criteria>
- GIT-01: File nodes show indicator for uncommitted changes (modified files) - DONE
- GIT-02: Staged files are visually distinct from unstaged files - DONE
- Users can identify git status at a glance in the 3D graph
</success_criteria>

<output>
After completion, create `.planning/phases/10-git-integration/10-02-SUMMARY.md`
</output>

---
phase: 08-activity-feed-change-indicators
plan: 02
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - src/renderer/renderer.js
autonomous: true

must_haves:
  truths:
    - "File changes appear in activity feed with timestamp and change type"
    - "Created files trigger green pulse animation on graph node"
    - "Modified files trigger yellow/orange pulse animation"
    - "Deleted files trigger red pulse and node fades out"
    - "Activity feed shows newest entries first"
  artifacts:
    - path: "src/renderer/renderer.js"
      provides: "Activity tracking and change-type animations"
      contains: "addActivityEntry"
  key_links:
    - from: "window.electronAPI.onFilesChanged"
      to: "addActivityEntry"
      via: "file change event handler"
      pattern: "onFilesChanged.*addActivityEntry"
    - from: "addActivityEntry"
      to: "flashNodeWithType"
      via: "animation trigger"
      pattern: "flashNodeWithType"
---

<objective>
Implement activity state management and change-type-specific node animations.

Purpose: Make file changes visible in real-time with distinct visual cues for create/modify/delete operations.
Output: Activity entries populate feed on file changes, nodes animate with type-appropriate colors.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/08-activity-feed-change-indicators/08-CONTEXT.md
@.planning/phases/08-activity-feed-change-indicators/08-01-SUMMARY.md
@src/renderer/renderer.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement activity entry management and feed updates</name>
  <files>src/renderer/renderer.js</files>
  <action>
Implement activity entry tracking and feed panel rendering:

1. Update activityEntries structure (if not already defined):
   ```javascript
   // Each entry: { id, path, event, timestamp, sourceType, nodeId }
   // event: 'add' (create), 'change' (modify), 'unlink' (delete)
   let activityEntries = [];
   const MAX_ACTIVITY_ENTRIES = 100; // Limit to prevent memory issues
   ```

2. Create addActivityEntry function:
   ```javascript
   function addActivityEntry(event, filePath, sourceType) {
     const nodeId = findNodeIdFromPath(filePath);

     // Map chokidar events to user-friendly types
     const eventMap = {
       'add': 'created',
       'change': 'modified',
       'unlink': 'deleted',
       'addDir': 'created',
       'unlinkDir': 'deleted'
     };

     const entry = {
       id: Date.now() + '-' + Math.random().toString(36).substr(2, 9),
       path: filePath,
       relativePath: getRelativePath(filePath), // Helper to show short path
       event: eventMap[event] || event,
       timestamp: Date.now(),
       sourceType: sourceType,
       nodeId: nodeId
     };

     // Add to front (newest first)
     activityEntries.unshift(entry);

     // Trim old entries
     if (activityEntries.length > MAX_ACTIVITY_ENTRIES) {
       activityEntries = activityEntries.slice(0, MAX_ACTIVITY_ENTRIES);
     }

     // Update badge if panel is closed
     const panel = document.getElementById('activity-panel');
     if (!panel || !panel.classList.contains('visible')) {
       activityUnreadCount++;
       updateActivityBadge();
       // Pulse the toggle button
       pulseActivityToggle();
     }

     updateActivityPanel();
     return entry;
   }
   ```

3. Create helper function for relative path display:
   ```javascript
   function getRelativePath(absolutePath) {
     if (!absolutePath) return '';
     const normalized = absolutePath.replace(/\\/g, '/');

     // Check for .planning/ path
     const planningIndex = normalized.indexOf('.planning/');
     if (planningIndex !== -1) {
       return '.planning/' + normalized.substring(planningIndex + '.planning/'.length);
     }

     // Check for src/ path
     const srcIndex = normalized.indexOf('/src/');
     if (srcIndex !== -1) {
       return 'src/' + normalized.substring(srcIndex + '/src/'.length);
     }

     // Fallback: show last 2 path segments
     const parts = normalized.split('/');
     return parts.slice(-2).join('/');
   }
   ```

4. Create pulseActivityToggle function for collapsed state notification:
   ```javascript
   function pulseActivityToggle() {
     const toggle = document.getElementById('activity-toggle');
     if (!toggle) return;

     toggle.classList.add('pulse');
     setTimeout(() => toggle.classList.remove('pulse'), 600);
   }
   ```

5. Update updateActivityPanel function (replace placeholder from Plan 01):
   ```javascript
   function updateActivityPanel() {
     const content = document.getElementById('activity-content');
     if (!content) return;

     if (activityEntries.length === 0) {
       content.innerHTML = '<div class="activity-empty">No recent activity</div>';
       return;
     }

     content.innerHTML = activityEntries.map(entry => {
       const icon = getActivityIcon(entry.event);
       const timeAgo = formatTimeAgo(entry.timestamp);

       return `
         <div class="activity-entry ${entry.event}"
              data-entry-id="${entry.id}"
              data-node-id="${entry.nodeId || ''}"
              data-timestamp="${entry.timestamp}"
              title="${new Date(entry.timestamp).toLocaleString()}">
           <span class="activity-icon">${icon}</span>
           <span class="activity-path">${entry.relativePath}</span>
           <span class="activity-type">${entry.event}</span>
           <span class="activity-time">${timeAgo}</span>
         </div>
       `;
     }).join('');
   }
   ```

6. Add helper functions:
   ```javascript
   function getActivityIcon(event) {
     switch (event) {
       case 'created': return '+';
       case 'modified': return '~';
       case 'deleted': return '-';
       default: return '?';
     }
   }

   function formatTimeAgo(timestamp) {
     const seconds = Math.floor((Date.now() - timestamp) / 1000);
     if (seconds < 60) return `${seconds}s ago`;
     const minutes = Math.floor(seconds / 60);
     if (minutes < 60) return `${minutes}m ago`;
     const hours = Math.floor(minutes / 60);
     if (hours < 24) return `${hours}h ago`;
     return new Date(timestamp).toLocaleDateString();
   }
   ```

7. Set up interval to update relative timestamps:
   ```javascript
   // Update relative timestamps every 30 seconds
   setInterval(() => {
     if (activityEntries.length > 0) {
       updateActivityPanel();
     }
   }, 30000);
   ```
  </action>
  <verify>
Run `npm start`, open a project, then edit/create/delete a file:
1. Activity entry appears in feed panel
2. Entry shows relative path, change type, and timestamp
3. Badge increments when panel is closed
4. Toggle button pulses briefly on new activity
5. Timestamps update over time ("2s ago" -> "1m ago")
  </verify>
  <done>
Activity entries populate correctly on file changes. Entries show all required information. Badge and toggle pulse work when panel is collapsed.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement change-type-specific node animations</name>
  <files>src/renderer/renderer.js</files>
  <action>
Create distinct animations for create/modify/delete operations:

1. Create flashNodeWithType function (replaces/enhances flashNode):
   ```javascript
   // Change type colors
   const changeTypeColors = {
     created: 0x2ECC71,  // Green
     modified: 0xF39C12, // Orange
     deleted: 0xE74C3C   // Red
   };

   function flashNodeWithType(nodeId, changeType) {
     const node = currentGraphData.nodes.find(n => n.id === nodeId);
     if (!node) {
       console.log('[Flash] Node not found:', nodeId);
       return;
     }

     const threeObj = node.__threeObj;
     if (!threeObj) {
       console.log('[Flash] No THREE object for node:', nodeId);
       return;
     }

     // Collect all materials
     const materials = [];
     if (threeObj.material) materials.push(threeObj.material);
     if (threeObj.children) {
       threeObj.children.forEach(child => {
         if (child.material) materials.push(child.material);
       });
     }

     if (materials.length === 0) return;

     // Cancel existing animation
     if (flashingNodes.has(nodeId)) {
       const existing = flashingNodes.get(nodeId);
       if (existing.rafId) cancelAnimationFrame(existing.rafId);
     }

     const originalColors = materials.map(m => m.color.getHex());
     const flashColor = changeTypeColors[changeType] || 0xFFFFFF;

     // Animation parameters
     const duration = 2000;
     const pulseCount = 3;
     const startTime = Date.now();

     // For deleted nodes, we'll fade out at the end
     const isDelete = changeType === 'deleted';
     const originalOpacities = materials.map(m => m.opacity || 1);

     function animate() {
       const elapsed = Date.now() - startTime;
       const progress = Math.min(elapsed / duration, 1);

       // Pulsing effect
       const pulsePhase = progress * pulseCount * Math.PI * 2;
       const pulse = Math.max(0, Math.sin(pulsePhase));
       const decay = 1 - progress;
       const intensity = pulse * decay;

       materials.forEach((material, i) => {
         // Color pulse
         material.color.setHex(lerpColor(originalColors[i], flashColor, intensity));

         // For delete: fade out opacity in last 50% of animation
         if (isDelete && progress > 0.5) {
           const fadeProgress = (progress - 0.5) * 2; // 0 to 1 over second half
           material.opacity = originalOpacities[i] * (1 - fadeProgress * 0.7);
         }
       });

       if (progress < 1) {
         const rafId = requestAnimationFrame(animate);
         flashingNodes.set(nodeId, { rafId, startTime, changeType });
       } else {
         // Restore original state (or leave faded for deleted)
         materials.forEach((material, i) => {
           material.color.setHex(originalColors[i]);
           if (!isDelete) {
             material.opacity = originalOpacities[i];
           }
           // For deleted nodes, leave them faded as visual indicator
         });
         flashingNodes.delete(nodeId);
       }
     }

     const rafId = requestAnimationFrame(animate);
     flashingNodes.set(nodeId, { rafId, startTime, changeType });
     console.log('[Flash] Started', changeType, 'flash for:', nodeId);
   }
   ```

2. Update the file change listener to use type-specific animations:
   Find the existing `window.electronAPI.onFilesChanged` handler and update it:
   ```javascript
   if (window.electronAPI && window.electronAPI.onFilesChanged) {
     window.electronAPI.onFilesChanged((data) => {
       console.log('Files changed:', data.event, data.path, 'sourceType:', data.sourceType);

       if (selectedProjectPath) {
         // Add to activity feed
         const entry = addActivityEntry(data.event, data.path, data.sourceType);

         // Flash the node with type-appropriate animation
         if (entry.nodeId) {
           flashNodeWithType(entry.nodeId, entry.event);
           flashTreeItem(entry.nodeId);
         }

         // Refresh the graph data
         showRefreshIndicator();
         loadProject(selectedProjectPath);
       }
     });
   }
   ```

3. Update flashTreeItem to support change types:
   ```javascript
   function flashTreeItem(nodeId, changeType = 'modified') {
     const treeItem = document.querySelector(`.tree-item[data-node-id="${nodeId}"]`);
     if (!treeItem) return;

     // Remove existing animation
     treeItem.classList.remove('tree-flash', 'tree-flash-created', 'tree-flash-modified', 'tree-flash-deleted');

     // Force reflow
     void treeItem.offsetWidth;

     // Add type-specific animation class
     const className = `tree-flash-${changeType}`;
     treeItem.classList.add(className);

     setTimeout(() => {
       treeItem.classList.remove(className);
     }, 2000);
   }
   ```

4. Keep original flashNode function as fallback (for manual flashes like tree clicks):
   - Rename to use flashNodeWithType internally
   ```javascript
   function flashNode(nodeId) {
     flashNodeWithType(nodeId, 'modified');
   }
   ```
  </action>
  <verify>
Run `npm start`, open a project, then:
1. Create a new file -> green pulse animation on new node
2. Modify existing file -> yellow/orange pulse animation
3. Delete a file -> red pulse animation, node fades out
4. All animations complete in ~2 seconds
5. Tree items also flash with appropriate colors
  </verify>
  <done>
Change-type-specific animations implemented. Created files pulse green, modified files pulse orange, deleted files pulse red and fade out. Tree panel items also show type-specific flash colors.
  </done>
</task>

</tasks>

<verification>
- [ ] New file creation shows entry with "created" type and green styling
- [ ] File modification shows entry with "modified" type and orange styling
- [ ] File deletion shows entry with "deleted" type and red styling
- [ ] Graph nodes pulse with correct colors (green/orange/red)
- [ ] Deleted nodes fade out after red pulse
- [ ] Entries appear with correct timestamp format
- [ ] Badge increments when panel is closed
- [ ] Toggle button pulses on new activity
- [ ] Timestamps update automatically (30-second interval)
</verification>

<success_criteria>
Activity tracking and animations working:
1. All file change types (create/modify/delete) recorded in feed
2. Entries display path, type, and relative timestamp
3. Graph nodes animate with change-type-specific colors
4. Delete animation includes fade-out effect
5. Badge and toggle pulse when panel is closed
</success_criteria>

<output>
After completion, create `.planning/phases/08-activity-feed-change-indicators/08-02-SUMMARY.md`
</output>

---
phase: 18-smooth-activity-updates
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/renderer/renderer.js
autonomous: true

must_haves:
  truths:
    - "Existing nodes stay in their positions when new nodes are added"
    - "Graph layout doesn't 'explode' or shift dramatically during updates"
    - "Only new nodes participate in force simulation until they settle"
  artifacts:
    - path: "src/renderer/renderer.js"
      provides: "Layout stability via fixed node positions"
      contains: "fixExistingNodePositions"
  key_links:
    - from: "applyIncrementalUpdate"
      to: "fixExistingNodePositions"
      via: "call before adding new nodes"
      pattern: "fixExistingNodePositions"
    - from: "node object"
      to: "fx, fy, fz properties"
      via: "position locking"
      pattern: "node\\.fx|node\\.fy|node\\.fz"
---

<objective>
Prevent existing nodes from moving when new nodes are added to the graph by fixing their positions.

Purpose: When graphData() is called with new nodes, the force simulation "reheats" and all nodes start moving to find new equilibrium. This causes the entire graph to shift and jump, which is disorienting. By fixing existing node positions (fx, fy, fz), only new nodes will move to find their place.

Output: Modified renderer.js with position-fixing logic that stabilizes existing nodes during incremental updates.
</objective>

<execution_context>
@/home/rafreid/.claude/get-shit-done/workflows/execute-plan.md
@/home/rafreid/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/renderer/renderer.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement position fixing for existing nodes</name>
  <files>src/renderer/renderer.js</files>
  <action>
In 3d-force-graph (and d3-force), setting `fx`, `fy`, `fz` on a node "fixes" it at that position - the simulation won't move it.

Create a function `fixExistingNodePositions()`:

```javascript
// Fix all existing nodes at their current positions
// Call this BEFORE adding new nodes to prevent layout disruption
function fixExistingNodePositions() {
  currentGraphData.nodes.forEach(node => {
    // Only fix if the node has settled (has position)
    if (node.x !== undefined && node.y !== undefined) {
      node.fx = node.x;
      node.fy = node.y;
      if (node.z !== undefined) {
        node.fz = node.z;
      }
    }
  });
}
```

Create a function `unfixNodePositions(nodeIds)` that removes fixed positions for specific nodes (used when we want nodes to relax):

```javascript
// Remove fixed positions from specified nodes (or all if no ids provided)
function unfixNodePositions(nodeIds = null) {
  currentGraphData.nodes.forEach(node => {
    if (nodeIds === null || nodeIds.includes(node.id)) {
      delete node.fx;
      delete node.fy;
      delete node.fz;
    }
  });
}
```

Modify `applyIncrementalUpdate()` to use these functions:

**For file create (add) events:**
```javascript
// 1. Fix existing nodes so they don't move
fixExistingNodePositions();

// 2. Build and add the new node (without fx/fy/fz - it will float to position)
const newNode = buildFileNode(path, sourceType);
currentGraphData.nodes.push(newNode);
// Add link to parent...

// 3. Update the graph
Graph.graphData(currentGraphData);

// 4. After a delay, unfix all nodes so future interactions feel natural
setTimeout(() => {
  unfixNodePositions();
}, 2000);  // 2 seconds to let new node settle
```

**For delete events:**
```javascript
// Fix existing nodes first
fixExistingNodePositions();

// Remove node and links...

// Update graph
Graph.graphData(currentGraphData);

// Unfix after settling
setTimeout(() => {
  unfixNodePositions();
}, 1000);  // Less time needed for delete
```

This approach:
- Prevents the jarring "explosion" when nodes are added
- Lets new nodes smoothly drift to their natural position
- Eventually unfixes nodes so manual dragging and layout adjustments still work
  </action>
  <verify>
Run `npm run build`. Test by:
1. Open project, wait for graph to settle
2. Add a file to a subdirectory (e.g., `touch src/test.js`)
3. Verify: Existing nodes stay in place, new node appears near its parent and settles
4. After 2 seconds, try dragging a node - should work (positions unfixed)
  </verify>
  <done>
Existing nodes maintain their positions when new nodes are added. Graph remains stable during incremental updates.
  </done>
</task>

<task type="auto">
  <name>Task 2: Position new nodes near their parent</name>
  <files>src/renderer/renderer.js</files>
  <action>
When adding a new node, position it near its parent so it doesn't appear at origin and drift far:

Modify `buildFileNode()` or the add logic in `applyIncrementalUpdate()`:

```javascript
function buildFileNode(filePath, sourceType) {
  // Determine parent directory node ID
  const pathParts = filePath.split('/');
  const fileName = pathParts.pop();
  const parentPath = pathParts.join('/');

  // Build parent node ID
  let parentId;
  if (parentPath === '') {
    // Direct child of root directory (planning or src)
    parentId = sourceType === 'planning' ? 'dir-planning' : 'dir-src';
  } else {
    parentId = `${sourceType}-dir-${parentPath}`;
  }

  // Find parent node to get its position
  const parentNode = currentGraphData.nodes.find(n => n.id === parentId);

  // Determine if this is a file or directory based on extension
  const isDirectory = !fileName.includes('.');
  const nodeType = isDirectory ? 'directory' : 'file';
  const nodeId = `${sourceType}-${nodeType === 'directory' ? 'dir' : 'file'}-${filePath}`;

  // Build node object
  const node = {
    id: nodeId,
    name: fileName,
    type: nodeType,
    path: filePath,
    sourceType: sourceType
  };

  // If it's a file, extract extension
  if (nodeType === 'file') {
    const ext = fileName.split('.').pop();
    node.extension = ext;
  }

  // Position near parent with some random offset
  if (parentNode && parentNode.x !== undefined) {
    const offset = 20;  // Distance from parent
    node.x = parentNode.x + (Math.random() - 0.5) * offset;
    node.y = parentNode.y + (Math.random() - 0.5) * offset;
    node.z = (parentNode.z || 0) + (Math.random() - 0.5) * offset;
  }

  return { node, parentId };
}
```

Update `applyIncrementalUpdate()` to use the returned parentId for linking:

```javascript
if (event === 'add' || event === 'addDir') {
  fixExistingNodePositions();

  const { node, parentId } = buildFileNode(path, sourceType);
  currentGraphData.nodes.push(node);

  // Add link to parent
  if (parentId) {
    currentGraphData.links.push({
      source: parentId,
      target: node.id,
      type: 'contains'
    });
  }

  // Save camera, update graph, restore camera
  const camPos = Graph.cameraPosition();
  Graph.graphData(currentGraphData);
  Graph.cameraPosition(camPos.x, camPos.y, camPos.z, 0);

  // Update storedDirectoryData for tree panel sync
  updateStoredDirectoryData('add', node);

  setTimeout(() => unfixNodePositions(), 2000);
}
```

Create helper to update storedDirectoryData:

```javascript
function updateStoredDirectoryData(operation, node) {
  if (!storedDirectoryData) return;

  if (operation === 'add') {
    // Add to nodes array
    storedDirectoryData.nodes.push({
      id: node.id,
      name: node.name,
      type: node.type,
      path: node.path,
      extension: node.extension,
      sourceType: node.sourceType
    });
  } else if (operation === 'remove') {
    // Remove from nodes array
    storedDirectoryData.nodes = storedDirectoryData.nodes.filter(n => n.id !== node.id);
    // Remove links
    storedDirectoryData.links = storedDirectoryData.links.filter(
      l => l.source !== node.id && l.target !== node.id
    );
  }
}
```
  </action>
  <verify>
Run `npm run build`. Test by:
1. Open project, note position of src/ folder
2. Create file in src/ subdirectory: `touch src/components/test.js`
3. Verify: New node appears NEAR the components directory, not at origin
4. Node smoothly settles into its final position
  </verify>
  <done>
New nodes are positioned near their parent directory and smoothly drift to equilibrium without disrupting existing layout.
  </done>
</task>

</tasks>

<verification>
1. Add multiple files in sequence - each appears without graph "explosion"
2. Existing nodes don't visibly move when new nodes are added
3. New nodes appear near their parent directory
4. After settling period, nodes can still be dragged
5. Delete operations also maintain layout stability
</verification>

<success_criteria>
- Adding a file: Only the new node moves (drifts from parent to equilibrium)
- Existing nodes: Stay exactly where they were before the add
- Position fixing: Temporary (2 seconds) then releases for normal interaction
- New node placement: Appears near parent, not at origin
- No regression: All other functionality continues to work
</success_criteria>

<output>
After completion, create `.planning/phases/18-smooth-activity-updates/18-02-SUMMARY.md`
</output>

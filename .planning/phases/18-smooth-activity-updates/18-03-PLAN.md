---
phase: 18-smooth-activity-updates
plan: 03
type: execute
wave: 2
depends_on: ["18-01", "18-02"]
files_modified:
  - src/renderer/renderer.js
autonomous: true

must_haves:
  truths:
    - "Deleted files fade out visually before being removed from graph"
    - "Fade animation is smooth (not abrupt disappearance)"
    - "Faded node is removed from data only after animation completes"
  artifacts:
    - path: "src/renderer/renderer.js"
      provides: "Fade-out animation for deleted nodes"
      contains: "fadeOutAndRemoveNode"
  key_links:
    - from: "applyIncrementalUpdate"
      to: "fadeOutAndRemoveNode"
      via: "call for unlink events"
      pattern: "fadeOutAndRemoveNode"
    - from: "fadeOutAndRemoveNode"
      to: "node.__threeObj"
      via: "opacity animation"
      pattern: "__threeObj.*opacity"
---

<objective>
Implement smooth fade-out animation when files are deleted, removing the node from the graph only after the animation completes.

Purpose: Currently deleted files just disappear instantly. A fade-out animation provides visual feedback that a file was deleted and makes the change less jarring.

Output: Modified renderer.js with fadeOutAndRemoveNode() function that animates opacity to 0, then removes the node from the graph.
</objective>

<execution_context>
@/home/rafreid/.claude/get-shit-done/workflows/execute-plan.md
@/home/rafreid/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/renderer/renderer.js
@.planning/phases/18-smooth-activity-updates/18-01-PLAN.md
@.planning/phases/18-smooth-activity-updates/18-02-PLAN.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create fade-out animation function</name>
  <files>src/renderer/renderer.js</files>
  <action>
Create a function `fadeOutAndRemoveNode(nodeId)` that:

1. Finds the node in currentGraphData by ID
2. Accesses its THREE.js object via `node.__threeObj`
3. Animates the material opacity from 1 to 0 over 500ms
4. After animation completes, removes the node from currentGraphData and calls graphData()

```javascript
// Fade out a node before removing it from the graph
function fadeOutAndRemoveNode(nodeId, duration = 500) {
  const node = currentGraphData.nodes.find(n => n.id === nodeId);
  if (!node) {
    console.log('[Fade] Node not found:', nodeId);
    return;
  }

  const threeObj = node.__threeObj;
  if (!threeObj) {
    // No THREE object yet (node may not have rendered)
    // Just remove immediately
    removeNodeFromGraph(nodeId);
    return;
  }

  const startTime = Date.now();
  const startOpacity = 1;
  const endOpacity = 0;

  function animate() {
    const elapsed = Date.now() - startTime;
    const progress = Math.min(elapsed / duration, 1);

    // Ease-out curve for smooth deceleration
    const eased = 1 - Math.pow(1 - progress, 2);
    const opacity = startOpacity + (endOpacity - startOpacity) * eased;

    // Apply opacity to material(s)
    if (threeObj.material) {
      threeObj.material.transparent = true;
      threeObj.material.opacity = opacity;
      threeObj.material.needsUpdate = true;
    }

    // Handle objects with multiple materials (like group)
    threeObj.traverse(child => {
      if (child.material) {
        child.material.transparent = true;
        child.material.opacity = opacity;
        child.material.needsUpdate = true;
      }
    });

    // Also scale down slightly for visual effect
    const scale = 1 - (0.3 * eased);  // Scale from 1 to 0.7
    threeObj.scale.set(scale, scale, scale);

    if (progress < 1) {
      requestAnimationFrame(animate);
    } else {
      // Animation complete - remove from graph
      removeNodeFromGraph(nodeId);
    }
  }

  requestAnimationFrame(animate);
}

// Helper to remove node from graph data
function removeNodeFromGraph(nodeId) {
  // Fix existing nodes before removal
  fixExistingNodePositions();

  // Remove from nodes array
  currentGraphData.nodes = currentGraphData.nodes.filter(n => n.id !== nodeId);

  // Remove links involving this node
  currentGraphData.links = currentGraphData.links.filter(
    l => {
      const sourceId = typeof l.source === 'object' ? l.source.id : l.source;
      const targetId = typeof l.target === 'object' ? l.target.id : l.target;
      return sourceId !== nodeId && targetId !== nodeId;
    }
  );

  // Save camera, update graph, restore camera
  const camPos = Graph.cameraPosition();
  Graph.graphData(currentGraphData);
  Graph.cameraPosition(camPos.x, camPos.y, camPos.z, 0);

  // Update storedDirectoryData
  updateStoredDirectoryData('remove', { id: nodeId });

  // If this was the selected node, close details panel
  if (selectedNode && selectedNode.id === nodeId) {
    hideDetailsPanel();
    selectedNode = null;
  }

  // Unfix after a short delay
  setTimeout(() => unfixNodePositions(), 1000);

  console.log('[Fade] Node removed:', nodeId);
}
```

Key implementation notes:
- THREE.js materials need `transparent = true` for opacity to work
- Use `traverse()` to handle complex node objects with multiple children
- Combine fade with slight scale-down for better visual effect
- Remove node only AFTER animation completes (not during)
  </action>
  <verify>
Run `npm run build`. Test by:
1. Open project, find a file node
2. Delete the file externally: `rm src/test-file.js`
3. Watch the graph: node should fade out over ~0.5 seconds, then disappear
4. No errors in console, no layout jumping
  </verify>
  <done>
Deleted file nodes fade out smoothly before being removed from graph.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate fade animation with incremental updates</name>
  <files>src/renderer/renderer.js</files>
  <action>
Update `applyIncrementalUpdate()` to use the fade animation for delete events:

```javascript
function applyIncrementalUpdate(changeEvent) {
  const { event, path, sourceType } = changeEvent;

  // Determine node ID from path and event type
  let nodeId;
  if (event === 'addDir' || event === 'unlinkDir') {
    nodeId = `${sourceType}-dir-${path}`;
  } else {
    nodeId = `${sourceType}-file-${path}`;
  }

  console.log('[Update] Incremental update:', event, nodeId);

  switch (event) {
    case 'add':
    case 'addDir': {
      // Fix existing nodes
      fixExistingNodePositions();

      // Build new node positioned near parent
      const { node, parentId } = buildFileNode(path, sourceType, event === 'addDir');

      // Check if node already exists (duplicate event)
      if (currentGraphData.nodes.find(n => n.id === node.id)) {
        console.log('[Update] Node already exists, skipping:', node.id);
        return;
      }

      currentGraphData.nodes.push(node);

      // Add link to parent
      if (parentId) {
        currentGraphData.links.push({
          source: parentId,
          target: node.id,
          type: 'contains'
        });
      }

      // Save camera, update graph, restore camera
      const camPos = Graph.cameraPosition();
      Graph.graphData(currentGraphData);
      Graph.cameraPosition(camPos.x, camPos.y, camPos.z, 0);

      // Update stored data for tree
      updateStoredDirectoryData('add', node);

      // Unfix nodes after settling
      setTimeout(() => unfixNodePositions(), 2000);
      break;
    }

    case 'change': {
      // Modify event - node already exists, no graph data change needed
      // Flash animation already handles visual feedback
      // Just update the selected node reference if needed
      updateSelectedNodeReference();
      break;
    }

    case 'unlink':
    case 'unlinkDir': {
      // Delete event - fade out then remove
      fadeOutAndRemoveNode(nodeId);
      break;
    }

    default:
      console.log('[Update] Unknown event type:', event);
  }
}
```

Also add duplicate detection to prevent issues when file watcher sends multiple events:

```javascript
// Track pending deletions to avoid duplicate animations
const pendingDeletions = new Set();

function fadeOutAndRemoveNode(nodeId, duration = 500) {
  // Prevent duplicate animations
  if (pendingDeletions.has(nodeId)) {
    console.log('[Fade] Already pending deletion:', nodeId);
    return;
  }
  pendingDeletions.add(nodeId);

  // ... rest of animation code ...

  // In the completion callback:
  function removeNodeFromGraph(nodeId) {
    pendingDeletions.delete(nodeId);
    // ... rest of removal code ...
  }
}
```
  </action>
  <verify>
Run `npm run build`. Test complete flow:
1. Create a file: `touch src/components/temp.js` - node appears smoothly
2. Modify the file: `echo "test" >> src/components/temp.js` - flash animation plays
3. Delete the file: `rm src/components/temp.js` - node fades out over 0.5s
4. Repeat rapidly - no duplicate animations or errors
5. Camera stays put through all operations
  </verify>
  <done>
Delete events trigger fade-out animation. Duplicate event handling prevents animation conflicts.
  </done>
</task>

<task type="auto">
  <name>Task 3: Handle edge cases for delete animation</name>
  <files>src/renderer/renderer.js</files>
  <action>
Handle edge cases that could cause issues with the fade animation:

1. **Directory deletion (recursive):**
   When a directory is deleted, the file watcher may send events for all children first.
   Handle by checking if parent still exists:

```javascript
function fadeOutAndRemoveNode(nodeId, duration = 500) {
  const node = currentGraphData.nodes.find(n => n.id === nodeId);
  if (!node) {
    // Node may have already been removed (parent deleted first)
    console.log('[Fade] Node already removed:', nodeId);
    pendingDeletions.delete(nodeId);
    return;
  }
  // ... rest of function
}
```

2. **Flash animation conflict:**
   If a node is flashing when deleted, cancel the flash:

```javascript
function fadeOutAndRemoveNode(nodeId, duration = 500) {
  // Cancel any active flash animation
  if (flashingNodes.has(nodeId)) {
    const flash = flashingNodes.get(nodeId);
    if (flash.rafId) {
      cancelAnimationFrame(flash.rafId);
    }
    flashingNodes.delete(nodeId);
  }
  // ... rest of function
}
```

3. **Heat tracking cleanup:**
   Remove deleted nodes from heat tracking:

```javascript
function removeNodeFromGraph(nodeId) {
  // Clear from heat tracking
  if (nodeHeatTimestamps.has(nodeId)) {
    nodeHeatTimestamps.delete(nodeId);
  }

  // Clear from pending deletions
  pendingDeletions.delete(nodeId);

  // ... rest of removal code
}
```

4. **Tree item fade sync:**
   Also fade the corresponding tree item (if visible):

```javascript
function fadeOutAndRemoveNode(nodeId, duration = 500) {
  // ... start of function ...

  // Also fade tree item
  const treeItem = document.querySelector(`.tree-item[data-id="${nodeId}"]`);
  if (treeItem) {
    treeItem.style.transition = `opacity ${duration}ms ease-out`;
    treeItem.style.opacity = '0';
  }

  // ... rest of animation ...
}
```

5. **Highlighted node cleanup:**
   Clear highlight if deleting highlighted node:

```javascript
function removeNodeFromGraph(nodeId) {
  // Clear highlight if this was the highlighted node
  if (highlightedNodeId === nodeId) {
    clearNodeHighlight();
  }
  // ... rest of function
}
```
  </action>
  <verify>
Test edge cases:
1. Delete a directory with files: `rm -rf src/test-dir/` - all nodes fade, no errors
2. Delete a file while it's flashing (create then immediately delete) - no animation conflict
3. Delete a file that's in the heat map - heat tracking cleaned up
4. Delete highlighted node - highlight clears properly
5. Delete selected node - details panel closes
  </verify>
  <done>
All edge cases handled: directory deletion, animation conflicts, heat/highlight cleanup, tree sync.
  </done>
</task>

</tasks>

<verification>
1. Delete a single file - smooth 500ms fade-out, then removal
2. Delete a directory with children - all nodes fade appropriately
3. Rapid create/delete cycle - no animation conflicts or errors
4. Delete while flashing - flash cancelled, fade plays
5. Delete selected node - details panel closes gracefully
6. Delete highlighted node - highlight clears
7. Camera position unchanged through all deletions
</verification>

<success_criteria>
- Single file delete: 500ms fade-out animation before removal
- Directory delete: All child nodes fade out
- Animation timing: Smooth ease-out curve, no abrupt changes
- Conflict handling: Flash animations cancelled before fade
- State cleanup: Heat, highlight, selection all properly cleared
- No errors: Console clean during all delete operations
</success_criteria>

<output>
After completion, create `.planning/phases/18-smooth-activity-updates/18-03-SUMMARY.md`
</output>

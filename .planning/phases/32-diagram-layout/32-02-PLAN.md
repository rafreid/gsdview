---
phase: 32-diagram-layout
plan: 02
type: execute
wave: 2
depends_on: ["32-01"]
files_modified:
  - src/renderer/diagram-renderer.js
  - src/renderer/index.html
autonomous: true

must_haves:
  truths:
    - "User sees 6 GSD stages in left-to-right horizontal pipeline"
    - "User sees stage containers with green/yellow/gray status indicators"
    - "User sees connection lines between sequential stages"
    - "User can scroll/pan horizontally to see full pipeline"
    - "User sees artifact blocks nested inside stage containers"
    - "User sees artifact status colors (green=done, yellow=in-progress, gray=missing)"
    - "User sees current stage highlighted based on STATE.md"
  artifacts:
    - path: "src/renderer/diagram-renderer.js"
      provides: "Complete D3.js SVG pipeline rendering"
      min_lines: 250
      contains: ["dagre.layout", "d3.select", "renderStages", "renderConnections"]
    - path: "src/renderer/index.html"
      provides: "Diagram-specific CSS styles"
      contains: [".diagram-stage", ".artifact-block", ".stage-connection"]
  key_links:
    - from: "diagram-renderer.js renderPipeline"
      to: "dagre layout"
      via: "dagre.layout(g) call"
      pattern: "dagre\\.layout"
    - from: "diagram-renderer.js"
      to: "SVG stages"
      via: "D3 data binding"
      pattern: "selectAll.*data.*enter"
---

<objective>
Implement full D3.js SVG rendering of the GSD workflow pipeline with 6 stages, artifact blocks, status indicators, and horizontal scroll/pan navigation.

Purpose: Transform the parsed pipeline data into a visual diagram that shows the GSD workflow stages, their artifacts, and completion status at a glance. This is the core visualization that makes the workflow structure visible.

Output: Fully rendered SVG diagram showing Initialize -> Discuss -> Plan -> Execute -> Verify -> Complete stages with nested artifacts and status colors.
</objective>

<execution_context>
@/home/rafreid/.claude/get-shit-done/workflows/execute-plan.md
@/home/rafreid/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/32-diagram-layout/32-01-SUMMARY.md

# Key source files
@src/renderer/diagram-renderer.js
@src/renderer/gsd-pipeline-parser.js
@src/renderer/index.html (CSS section)
@src/renderer/state-manager.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement dagre layout and D3.js stage rendering</name>
  <files>src/renderer/diagram-renderer.js</files>
  <action>
Replace the placeholder renderPipeline() with full implementation:

**1. Layout Constants:**
```javascript
const STAGE_WIDTH = 200;
const STAGE_HEIGHT = 300;
const STAGE_MARGIN = 80;  // Horizontal gap between stages
const ARTIFACT_HEIGHT = 40;
const ARTIFACT_MARGIN = 8;
const PADDING = 50;  // Canvas padding
```

**2. Status Colors:**
```javascript
const STATUS_COLORS = {
  complete: '#2ECC71',    // Green
  'in-progress': '#F39C12', // Yellow/orange
  pending: '#95A5A6',     // Gray
  done: '#2ECC71',        // Green (artifact-level)
  missing: '#95A5A6'      // Gray (artifact-level)
};

const STAGE_COLORS = {
  initialize: '#FF6B6B',  // Coral
  discuss: '#4ECDC4',     // Teal
  plan: '#45B7D1',        // Sky blue
  execute: '#98D8C8',     // Mint
  verify: '#F7DC6F',      // Gold
  complete: '#2ECC71'     // Green
};
```

**3. Create dagre graph:**
```javascript
function createLayout(data) {
  const g = new dagre.graphlib.Graph();
  g.setGraph({
    rankdir: 'LR',  // Left to right
    nodesep: STAGE_MARGIN,
    ranksep: STAGE_MARGIN,
    marginx: PADDING,
    marginy: PADDING
  });
  g.setDefaultEdgeLabel(() => ({}));

  // Add stage nodes
  data.stages.forEach((stage, i) => {
    const artifactHeight = stage.artifacts.length * (ARTIFACT_HEIGHT + ARTIFACT_MARGIN);
    g.setNode(stage.id, {
      width: STAGE_WIDTH,
      height: Math.max(STAGE_HEIGHT, artifactHeight + 80),
      stage: stage
    });
  });

  // Add edges between sequential stages
  for (let i = 0; i < data.stages.length - 1; i++) {
    g.setEdge(data.stages[i].id, data.stages[i + 1].id);
  }

  dagre.layout(g);
  return g;
}
```

**4. Render stages as rectangles:**
```javascript
function renderStages(container, layoutGraph, currentStage) {
  const nodes = layoutGraph.nodes().map(id => layoutGraph.node(id));

  // Stage groups
  const stageGroups = container.selectAll('.stage-group')
    .data(nodes, d => d.stage.id)
    .enter()
    .append('g')
    .attr('class', 'stage-group')
    .attr('transform', d => `translate(${d.x - d.width/2}, ${d.y - d.height/2})`);

  // Stage background rectangle
  stageGroups.append('rect')
    .attr('class', 'diagram-stage')
    .attr('width', d => d.width)
    .attr('height', d => d.height)
    .attr('rx', 8)
    .attr('fill', d => d.stage.id === currentStage ? STAGE_COLORS[d.stage.id] + '33' : '#1a1a2e')
    .attr('stroke', d => STAGE_COLORS[d.stage.id])
    .attr('stroke-width', d => d.stage.id === currentStage ? 3 : 2);

  // Stage header
  stageGroups.append('rect')
    .attr('class', 'stage-header')
    .attr('width', d => d.width)
    .attr('height', 40)
    .attr('rx', 8)
    .attr('fill', d => STAGE_COLORS[d.stage.id]);

  // Stage name
  stageGroups.append('text')
    .attr('class', 'stage-name')
    .attr('x', d => d.width / 2)
    .attr('y', 26)
    .attr('text-anchor', 'middle')
    .attr('fill', '#fff')
    .attr('font-size', '16px')
    .attr('font-weight', 'bold')
    .text(d => d.stage.name);

  // Status indicator dot
  stageGroups.append('circle')
    .attr('class', 'status-indicator')
    .attr('cx', d => d.width - 20)
    .attr('cy', 20)
    .attr('r', 8)
    .attr('fill', d => STATUS_COLORS[d.stage.status] || STATUS_COLORS.pending);

  return stageGroups;
}
```

**5. Render connection lines:**
```javascript
function renderConnections(container, layoutGraph) {
  const edges = layoutGraph.edges().map(e => ({
    source: layoutGraph.node(e.v),
    target: layoutGraph.node(e.w)
  }));

  container.selectAll('.stage-connection')
    .data(edges)
    .enter()
    .append('line')
    .attr('class', 'stage-connection')
    .attr('x1', d => d.source.x + d.source.width/2)
    .attr('y1', d => d.source.y)
    .attr('x2', d => d.target.x - d.target.width/2)
    .attr('y2', d => d.target.y)
    .attr('stroke', '#4ECDC4')
    .attr('stroke-width', 3)
    .attr('stroke-dasharray', '8,4')
    .attr('marker-end', 'url(#arrowhead)');

  // Add arrowhead marker definition
  container.append('defs')
    .append('marker')
    .attr('id', 'arrowhead')
    .attr('viewBox', '0 -5 10 10')
    .attr('refX', 8)
    .attr('refY', 0)
    .attr('markerWidth', 6)
    .attr('markerHeight', 6)
    .attr('orient', 'auto')
    .append('path')
    .attr('d', 'M0,-5L10,0L0,5')
    .attr('fill', '#4ECDC4');
}
```

**6. Update renderPipeline to use these functions:**
```javascript
function renderPipeline(container, data) {
  // Create layout
  const layoutGraph = createLayout(data);

  // Calculate SVG dimensions
  const bounds = getBounds(layoutGraph);
  svg.attr('viewBox', `0 0 ${bounds.width + PADDING*2} ${bounds.height + PADDING*2}`);

  // Render connections first (behind stages)
  renderConnections(container, layoutGraph);

  // Render stages
  const currentStage = getCurrentStage(data.currentPhase);
  const stageGroups = renderStages(container, layoutGraph, currentStage);

  // Render artifacts inside stages (Task 2 will expand this)
  stageGroups.each(function(d) {
    renderArtifacts(d3.select(this), d.stage);
  });
}

function getBounds(layoutGraph) {
  let maxX = 0, maxY = 0;
  layoutGraph.nodes().forEach(id => {
    const node = layoutGraph.node(id);
    maxX = Math.max(maxX, node.x + node.width/2);
    maxY = Math.max(maxY, node.y + node.height/2);
  });
  return { width: maxX, height: maxY };
}

function getCurrentStage(currentPhase) {
  // Map phase to stage based on artifacts present
  // This will be refined - for now use 'plan' if phase exists
  return currentPhase?.stage || 'plan';
}
```
  </action>
  <verify>
1. Run `npm run build`
2. Run `npm start`
3. Open project folder
4. Click "Diagram" tab
5. Should see 6 horizontally arranged stage boxes with headers
6. Should see dashed connection lines with arrows between stages
7. Current stage should have highlighted border
8. Check DevTools console for no errors
  </verify>
  <done>
6 GSD stages render left-to-right with dagre layout. Stages have colored headers, status indicator dots, and are connected by dashed arrows. Current stage is highlighted.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement artifact blocks with status colors</name>
  <files>src/renderer/diagram-renderer.js</files>
  <action>
Expand the renderArtifacts function to show nested artifact blocks inside each stage:

```javascript
function renderArtifacts(stageGroup, stage) {
  if (!stage.artifacts || stage.artifacts.length === 0) {
    // Show "No artifacts" placeholder for empty stages
    stageGroup.append('text')
      .attr('class', 'no-artifacts')
      .attr('x', STAGE_WIDTH / 2)
      .attr('y', 80)
      .attr('text-anchor', 'middle')
      .attr('fill', '#666')
      .attr('font-size', '12px')
      .attr('font-style', 'italic')
      .text('No artifacts');
    return;
  }

  const artifactGroup = stageGroup.append('g')
    .attr('class', 'artifacts-container')
    .attr('transform', 'translate(10, 50)');  // Below header

  const artifacts = artifactGroup.selectAll('.artifact-block')
    .data(stage.artifacts)
    .enter()
    .append('g')
    .attr('class', 'artifact-block')
    .attr('transform', (d, i) => `translate(0, ${i * (ARTIFACT_HEIGHT + ARTIFACT_MARGIN)})`);

  // Artifact background
  artifacts.append('rect')
    .attr('class', 'artifact-bg')
    .attr('width', STAGE_WIDTH - 20)
    .attr('height', ARTIFACT_HEIGHT)
    .attr('rx', 4)
    .attr('fill', d => getArtifactFill(d.status))
    .attr('stroke', d => getArtifactStroke(d.status))
    .attr('stroke-width', 1);

  // Status indicator bar on left
  artifacts.append('rect')
    .attr('class', 'artifact-status-bar')
    .attr('width', 4)
    .attr('height', ARTIFACT_HEIGHT)
    .attr('rx', 2)
    .attr('fill', d => STATUS_COLORS[d.status] || STATUS_COLORS.pending);

  // Artifact icon
  artifacts.append('text')
    .attr('class', 'artifact-icon')
    .attr('x', 14)
    .attr('y', ARTIFACT_HEIGHT / 2 + 5)
    .attr('font-size', '14px')
    .text(d => getArtifactIcon(d.name));

  // Artifact name
  artifacts.append('text')
    .attr('class', 'artifact-name')
    .attr('x', 32)
    .attr('y', ARTIFACT_HEIGHT / 2 + 4)
    .attr('fill', '#fff')
    .attr('font-size', '12px')
    .text(d => truncateName(d.name, 18));

  // Status text
  artifacts.append('text')
    .attr('class', 'artifact-status-text')
    .attr('x', STAGE_WIDTH - 30)
    .attr('y', ARTIFACT_HEIGHT / 2 + 4)
    .attr('text-anchor', 'end')
    .attr('fill', d => STATUS_COLORS[d.status] || '#888')
    .attr('font-size', '10px')
    .text(d => d.status === 'done' ? '‚úì' : d.status === 'in-progress' ? '‚óê' : '‚óã');
}

function getArtifactFill(status) {
  switch (status) {
    case 'done': return '#2ECC7122';       // Green tint
    case 'in-progress': return '#F39C1222'; // Yellow tint
    default: return '#95A5A622';            // Gray tint
  }
}

function getArtifactStroke(status) {
  switch (status) {
    case 'done': return '#2ECC71';
    case 'in-progress': return '#F39C12';
    default: return '#95A5A6';
  }
}

function getArtifactIcon(name) {
  if (name.includes('CONTEXT')) return 'üí¨';
  if (name.includes('RESEARCH')) return 'üî¨';
  if (name.includes('PLAN')) return 'üìã';
  if (name.includes('SUMMARY')) return '‚úÖ';
  if (name.includes('VERIFICATION')) return 'üîç';
  if (name.includes('UAT')) return 'üë§';
  return 'üìÑ';
}

function truncateName(name, maxLen) {
  if (name.length <= maxLen) return name;
  return name.slice(0, maxLen - 3) + '...';
}
```

Also update the gsd-pipeline-parser.js to populate artifacts correctly for each stage. Ensure each phase's artifacts are associated with their corresponding stage:

- Discuss stage: CONTEXT.md, RESEARCH.md from each phase
- Plan stage: *-PLAN.md files from each phase
- Execute stage: *-SUMMARY.md files from each phase
- Verify stage: *-VERIFICATION.md, *-UAT.md files from each phase
  </action>
  <verify>
1. Run `npm run build`
2. Run `npm start`
3. Click "Diagram" tab
4. Each stage should show nested artifact blocks
5. Artifacts should have colored left border (green/yellow/gray based on status)
6. Artifact names should be visible with icons
7. Status indicators (checkmark/half-circle/circle) should be visible
  </verify>
  <done>
Artifact blocks render inside stage containers with name, icon, and status color. Green for done, yellow for in-progress, gray for missing. Status symbols (checkmark, half-circle, circle) indicate completion state.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add horizontal scroll/pan and CSS styles</name>
  <files>src/renderer/diagram-renderer.js, src/renderer/index.html</files>
  <action>
**1. Add scroll/pan support in diagram-renderer.js:**

```javascript
// Add after svg creation in mount()
function setupPanZoom(svgElement, contentGroup) {
  let isPanning = false;
  let startX = 0;
  let currentX = 0;

  // Mouse wheel for horizontal scroll
  svgElement.on('wheel', function(event) {
    event.preventDefault();
    currentX -= event.deltaY;
    currentX = Math.min(0, Math.max(currentX, -(contentWidth - containerWidth)));
    contentGroup.attr('transform', `translate(${currentX}, 0)`);
  });

  // Drag to pan
  svgElement.on('mousedown', function(event) {
    if (event.button !== 0) return; // Left click only
    isPanning = true;
    startX = event.clientX - currentX;
    svgElement.style('cursor', 'grabbing');
  });

  svgElement.on('mousemove', function(event) {
    if (!isPanning) return;
    currentX = event.clientX - startX;
    currentX = Math.min(0, Math.max(currentX, -(contentWidth - containerWidth)));
    contentGroup.attr('transform', `translate(${currentX}, 0)`);
  });

  svgElement.on('mouseup mouseleave', function() {
    isPanning = false;
    svgElement.style('cursor', 'grab');
  });
}

// Calculate content and container dimensions
let contentWidth = 0;
let containerWidth = 0;

// In mount(), after createLayout:
contentWidth = bounds.width + PADDING * 2;
containerWidth = container.getBoundingClientRect().width;

// Set SVG to fixed height, scrollable width
svg.attr('width', contentWidth)
   .attr('height', bounds.height + PADDING * 2)
   .style('cursor', 'grab');

setupPanZoom(svg, g);
```

**2. Add CSS styles in index.html (in the existing style section):**

Add these styles within the `<style>` tag, near the other diagram-container styles:

```css
/* Diagram View Styles */
.diagram-svg {
  background: #1a1a2e;
}

.diagram-stage {
  transition: stroke-width 0.2s ease;
}

.diagram-stage:hover {
  stroke-width: 3;
  filter: brightness(1.1);
}

.stage-header {
  cursor: pointer;
}

.artifact-block {
  cursor: pointer;
  transition: transform 0.1s ease;
}

.artifact-block:hover {
  transform: translateX(2px);
}

.artifact-block:hover .artifact-bg {
  filter: brightness(1.2);
}

.stage-connection {
  pointer-events: none;
}

.status-indicator {
  filter: drop-shadow(0 0 4px currentColor);
}

/* Scroll hint overlay */
.scroll-hint {
  position: absolute;
  bottom: 20px;
  left: 50%;
  transform: translateX(-50%);
  background: rgba(0, 0, 0, 0.7);
  color: #888;
  padding: 8px 16px;
  border-radius: 4px;
  font-size: 12px;
  pointer-events: none;
  opacity: 0.8;
}

.scroll-hint::after {
  content: '‚Üê Scroll or drag to pan ‚Üí';
}
```

**3. Add scroll hint element:**

In the mount() function, after creating the SVG:
```javascript
// Add scroll hint (fades after 3 seconds)
const hint = document.createElement('div');
hint.className = 'scroll-hint';
container.appendChild(hint);
setTimeout(() => hint.remove(), 3000);
```

**4. Add current phase highlighting:**

Update renderStages to add special styling when a stage contains the current phase:
```javascript
// After creating stage rectangles, add pulse animation to current stage
stageGroups.filter(d => d.stage.id === currentStage)
  .select('.diagram-stage')
  .classed('current-stage', true)
  .style('animation', 'pulse-stage 2s ease-in-out infinite');

// Add CSS animation
const styleSheet = document.styleSheets[0];
styleSheet.insertRule(`
  @keyframes pulse-stage {
    0%, 100% { stroke-opacity: 1; }
    50% { stroke-opacity: 0.6; }
  }
`, styleSheet.cssRules.length);
```
  </action>
  <verify>
1. Run `npm run build`
2. Run `npm start`
3. Click "Diagram" tab
4. Scroll hint should appear briefly at bottom
5. Mouse wheel should scroll diagram horizontally
6. Click and drag should pan the diagram
7. Current stage should have pulsing border
8. Hover on stages and artifacts should show visual feedback
9. Test with tree panel open/closed - diagram should resize correctly
  </verify>
  <done>
Horizontal scroll/pan works via mouse wheel and drag. Current stage has pulsing highlight. CSS hover effects on stages and artifacts. Scroll hint appears briefly on mount. Diagram responsive to panel open/close.
  </done>
</task>

</tasks>

<verification>
**Requirements Coverage:**

1. DIAG-01: Pipeline shows 6 GSD stages (Initialize -> ... -> Complete) ‚úì
   - dagre layout positions 6 stages left-to-right
   - Each stage has colored header with name

2. DIAG-02: Stages display with distinct status indicators ‚úì
   - Status dot in stage header (green/yellow/gray)
   - Stage border color matches stage identity

3. DIAG-03: Connection lines show sequential workflow flow ‚úì
   - Dashed lines with arrowhead markers between stages

4. DIAG-04: Layout supports horizontal scroll/pan ‚úì
   - Mouse wheel scrolls, drag pans
   - Scroll hint on mount

5. ARTF-01: Artifact blocks nest within stage containers ‚úì
   - Artifacts render inside stage groups below header

6. ARTF-02: Each artifact shows completion status ‚úì
   - Status symbols and colors per artifact

7. ARTF-03: Status colors (green/yellow/gray) ‚úì
   - Consistent color scheme across stages and artifacts

8. ARTF-04: Current stage highlighted based on STATE.md ‚úì
   - Pulsing border on current stage
   - Determined from currentPhase data
</verification>

<success_criteria>
- 6 GSD stages visible in horizontal left-to-right layout
- Connection lines with arrows between sequential stages
- Stage containers have header, status dot, and artifact blocks
- Artifacts show name, icon, and status color (green/yellow/gray)
- Current stage has pulsing highlight
- Mouse wheel and drag pan works horizontally
- No console errors during rendering or interaction
</success_criteria>

<output>
After completion, create `.planning/phases/32-diagram-layout/32-02-SUMMARY.md`
</output>

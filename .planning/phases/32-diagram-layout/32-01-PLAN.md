---
phase: 32-diagram-layout
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - src/renderer/gsd-pipeline-parser.js
  - src/renderer/diagram-renderer.js
  - src/renderer/view-controller.js
autonomous: true

must_haves:
  truths:
    - "D3.js and dagre are available as dependencies"
    - "Pipeline parser extracts current phase and artifact status from STATE.md"
    - "Diagram renderer has mount/unmount lifecycle matching graph-renderer pattern"
  artifacts:
    - path: "package.json"
      provides: "D3.js and dagre dependencies"
      contains: ["d3", "@dagrejs/dagre"]
    - path: "src/renderer/gsd-pipeline-parser.js"
      provides: "GSD pipeline data extraction"
      exports: ["parsePipelineState", "getArtifactStatus"]
      min_lines: 80
    - path: "src/renderer/diagram-renderer.js"
      provides: "Diagram view lifecycle management"
      exports: ["mount", "unmount"]
      min_lines: 50
  key_links:
    - from: "src/renderer/view-controller.js"
      to: "src/renderer/diagram-renderer.js"
      via: "import mount/unmount"
      pattern: "import.*from.*diagram-renderer"
    - from: "src/renderer/diagram-renderer.js"
      to: "src/renderer/gsd-pipeline-parser.js"
      via: "import parsePipelineState"
      pattern: "import.*from.*gsd-pipeline-parser"
---

<objective>
Create foundation infrastructure for diagram view: D3.js/dagre dependencies, GSD pipeline parser, and diagram renderer skeleton with lifecycle methods.

Purpose: Establish the data layer and module structure before implementing visual rendering. The parser transforms STATE.md and phase artifacts into structured pipeline data; the renderer skeleton matches the graph-renderer lifecycle pattern for clean view switching.

Output: Working build with new dependencies, pipeline parser module, and diagram renderer skeleton wired into view-controller.
</objective>

<execution_context>
@/home/rafreid/.claude/get-shit-done/workflows/execute-plan.md
@/home/rafreid/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/31-view-switching/31-02-SUMMARY.md

# Key source files
@src/renderer/view-controller.js
@src/renderer/state-manager.js
@src/renderer/graph-renderer.js (first 150 lines - for lifecycle pattern reference)
@package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install D3.js and dagre dependencies</name>
  <files>package.json</files>
  <action>
Install D3.js v7 and dagre layout library:

```bash
npm install d3@^7.9.0 @dagrejs/dagre@^2.0.0
```

Verify package.json now includes:
- "d3": "^7.9.0" in dependencies
- "@dagrejs/dagre": "^2.0.0" in dependencies

Run `npm run build` to confirm esbuild can bundle the new dependencies.

Note: D3.js v7 uses ES modules natively which works well with our esbuild bundling.
  </action>
  <verify>
Run: `npm run build`
Expected: Build succeeds, bundle.js includes d3 and dagre code
Check: `grep -l "d3" package.json` returns package.json
  </verify>
  <done>
package.json contains d3 and @dagrejs/dagre dependencies, npm run build succeeds
  </done>
</task>

<task type="auto">
  <name>Task 2: Create GSD pipeline parser</name>
  <files>src/renderer/gsd-pipeline-parser.js</files>
  <action>
Create a new module that parses GSD project state and extracts pipeline data.

**Data structure to produce:**

```javascript
{
  stages: [
    {
      id: 'initialize',
      name: 'Initialize',
      status: 'complete',  // complete|in-progress|pending
      artifacts: []  // Initialize stage has no artifacts
    },
    {
      id: 'discuss',
      name: 'Discuss',
      status: 'complete',
      artifacts: [
        { name: 'CONTEXT.md', path: '.planning/phases/01-foundation/01-CONTEXT.md', status: 'done' }
      ]
    },
    // ... etc for Plan, Execute, Verify, Complete stages
  ],
  currentPhase: {
    number: 32,
    name: 'diagram-layout',
    stage: 'plan'  // Which GSD stage this phase is in
  },
  phases: [
    {
      number: 30,
      name: 'architecture-foundation',
      stage: 'complete',
      artifacts: [...]
    },
    // ...
  ]
}
```

**Implementation:**

1. **parsePipelineState(projectPath)** - Main function that:
   - Reads STATE.md to get current phase number
   - Scans .planning/phases/ directory for phase folders
   - For each phase, determines stage and collects artifacts
   - Returns structured pipeline data

2. **getPhaseStage(phaseDir)** - Determines which GSD stage a phase is in:
   - Check for CONTEXT.md → Discuss stage
   - Check for RESEARCH.md → Discuss stage (research variant)
   - Check for *-PLAN.md files → Plan stage
   - Check for *-SUMMARY.md files → Execute stage (completed plans)
   - Check for *-VERIFICATION.md → Verify stage
   - If all plans have summaries → Complete stage

3. **getArtifactStatus(artifactPath)** - Determines artifact completion:
   - File exists with content > 50 bytes → 'done'
   - File exists but empty/stub → 'in-progress'
   - File doesn't exist → 'missing'

4. **GSD_STAGES** constant defining the 6 stages with their artifact patterns:
   ```javascript
   const GSD_STAGES = [
     { id: 'initialize', name: 'Initialize', artifactPatterns: [] },
     { id: 'discuss', name: 'Discuss', artifactPatterns: ['CONTEXT.md', 'RESEARCH.md'] },
     { id: 'plan', name: 'Plan', artifactPatterns: ['*-PLAN.md'] },
     { id: 'execute', name: 'Execute', artifactPatterns: ['*-SUMMARY.md'] },
     { id: 'verify', name: 'Verify', artifactPatterns: ['*-VERIFICATION.md', '*-UAT.md'] },
     { id: 'complete', name: 'Complete', artifactPatterns: [] }
   ];
   ```

Use synchronous file operations (fs.existsSync, fs.readdirSync) for simplicity since this runs in renderer with nodeIntegration.

Export: parsePipelineState, getArtifactStatus, GSD_STAGES
  </action>
  <verify>
Verify with Node.js REPL or test:
```javascript
const { parsePipelineState } = require('./src/renderer/gsd-pipeline-parser.js');
const data = parsePipelineState('/path/to/project');
console.log(data.currentPhase);  // Should show current phase
console.log(data.stages.length); // Should be 6
```
  </verify>
  <done>
gsd-pipeline-parser.js exports parsePipelineState that returns structured pipeline data with 6 stages, current phase info, and artifact statuses
  </done>
</task>

<task type="auto">
  <name>Task 3: Create diagram renderer skeleton with lifecycle</name>
  <files>src/renderer/diagram-renderer.js, src/renderer/view-controller.js</files>
  <action>
**Create src/renderer/diagram-renderer.js:**

Follow the graph-renderer.js lifecycle pattern:

```javascript
/**
 * Diagram Renderer
 *
 * SVG-based workflow diagram using D3.js and dagre layout.
 * Visualizes GSD pipeline stages with nested artifact blocks.
 */

import * as d3 from 'd3';
import dagre from '@dagrejs/dagre';
import { state, subscribe } from './state-manager.js';
import { parsePipelineState, GSD_STAGES } from './gsd-pipeline-parser.js';

// SVG container reference
let svg = null;
let pipelineData = null;

/**
 * Mount the diagram view
 * Called when switching to diagram view
 */
export function mount() {
  console.log('[DiagramRenderer] Mounting...');

  const container = document.getElementById('diagram-container');
  if (!container) {
    console.error('[DiagramRenderer] diagram-container not found');
    return;
  }

  // Clear placeholder content
  container.innerHTML = '';

  // Create SVG element
  svg = d3.select(container)
    .append('svg')
    .attr('width', '100%')
    .attr('height', '100%')
    .attr('class', 'diagram-svg');

  // Add pan/scroll group
  const g = svg.append('g').attr('class', 'diagram-content');

  // Load and render pipeline data
  if (state.selectedProjectPath) {
    pipelineData = parsePipelineState(state.selectedProjectPath);
    renderPipeline(g, pipelineData);
  } else {
    renderPlaceholder(g);
  }

  console.log('[DiagramRenderer] Mounted');
}

/**
 * Unmount the diagram view
 * Called when switching away from diagram view
 */
export function unmount() {
  console.log('[DiagramRenderer] Unmounting...');

  // Clear SVG reference
  svg = null;
  pipelineData = null;

  console.log('[DiagramRenderer] Unmounted');
}

/**
 * Render placeholder when no project loaded
 */
function renderPlaceholder(g) {
  g.append('text')
    .attr('x', 200)
    .attr('y', 100)
    .attr('fill', '#888')
    .attr('font-size', '18px')
    .text('Open a project to view the GSD workflow diagram');
}

/**
 * Render pipeline stages (stub for Phase 32-02)
 */
function renderPipeline(g, data) {
  // Placeholder - will be implemented in 32-02
  g.append('text')
    .attr('x', 50)
    .attr('y', 50)
    .attr('fill', '#4ECDC4')
    .attr('font-size', '24px')
    .text('GSD Workflow Pipeline');

  g.append('text')
    .attr('x', 50)
    .attr('y', 80)
    .attr('fill', '#aaa')
    .attr('font-size', '14px')
    .text(`Current Phase: ${data.currentPhase?.number || 'N/A'} - ${data.currentPhase?.name || 'Unknown'}`);

  g.append('text')
    .attr('x', 50)
    .attr('y', 110)
    .attr('fill', '#aaa')
    .attr('font-size', '14px')
    .text(`Stages: ${data.stages?.length || 0} | Phases: ${data.phases?.length || 0}`);
}
```

**Update src/renderer/view-controller.js:**

Replace the TODO comments with actual imports and calls:

1. Add import at top:
   ```javascript
   import { mount as mountDiagram, unmount as unmountDiagram } from './diagram-renderer.js';
   ```

2. In switchToView('diagram') block:
   - Replace `// TODO: mountDiagram() in Phase 32` with `mountDiagram();`

3. In switchToView('graph') block:
   - Replace `// TODO: unmountDiagram() in Phase 32` with `unmountDiagram();`

4. Remove the placeholder console.log for diagram mount
  </action>
  <verify>
1. Run `npm run build` - should succeed
2. Run app with `npm start`
3. Open a project folder
4. Click "Diagram" tab
5. Should see teal "GSD Workflow Pipeline" text with current phase info
6. Click "Graph" tab - should switch back to 3D graph
7. Check DevTools console for mount/unmount logs
  </verify>
  <done>
diagram-renderer.js has mount/unmount lifecycle, creates SVG container, shows placeholder pipeline info. view-controller.js wires mount/unmount calls. View switching works between Graph and Diagram tabs.
  </done>
</task>

</tasks>

<verification>
1. `npm run build` succeeds with no errors
2. package.json contains d3 and @dagrejs/dagre dependencies
3. gsd-pipeline-parser.js exports parsePipelineState function
4. diagram-renderer.js exports mount and unmount functions
5. view-controller.js imports from diagram-renderer.js
6. Switching to Diagram view shows SVG with placeholder content
7. Switching back to Graph view shows 3D graph
8. No console errors during view switching
</verification>

<success_criteria>
- D3.js ^7.9.0 and @dagrejs/dagre ^2.0.0 in package.json dependencies
- parsePipelineState returns structured data with 6 stages and current phase
- Diagram view mounts/unmounts cleanly without memory leaks
- View switching works without errors between Graph and Diagram tabs
</success_criteria>

<output>
After completion, create `.planning/phases/32-diagram-layout/32-01-SUMMARY.md`
</output>

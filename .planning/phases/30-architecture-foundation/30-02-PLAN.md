---
phase: 30-architecture-foundation
plan: 02
type: execute
wave: 2
depends_on: ["30-01"]
files_modified:
  - src/renderer/renderer.js
  - src/renderer/graph-renderer.js
autonomous: true

must_haves:
  truths:
    - "Graph renderer imports state from state-manager.js"
    - "All state access uses imported state object"
    - "Renderer exposes mount() and unmount() lifecycle methods"
    - "All animation frame IDs are tracked and canceled on unmount"
  artifacts:
    - path: "src/renderer/graph-renderer.js"
      provides: "Refactored graph rendering module"
      exports: ["mount", "unmount", "getGraph"]
      contains: "import.*state-manager"
    - path: "src/renderer/renderer.js"
      provides: "Entry point that imports graph-renderer"
      contains: "import.*graph-renderer"
  key_links:
    - from: "src/renderer/graph-renderer.js"
      to: "src/renderer/state-manager.js"
      via: "ES module import"
      pattern: "import.*from.*state-manager"
    - from: "src/renderer/graph-renderer.js"
      to: "animation loops"
      via: "tracked RAF IDs with cancel on unmount"
      pattern: "cancelAnimationFrame"
---

<objective>
Refactor renderer.js to graph-renderer.js with state imports and lifecycle methods

Purpose: ARCH-02 requires renderer refactored to graph-renderer.js with state imports. ARCH-03 requires explicit mount/unmount lifecycle. ARCH-04 requires animation frame cleanup patterns.

Output: A refactored graph-renderer.js that imports state from state-manager.js and has proper lifecycle management.
</objective>

<execution_context>
@/home/rafreid/.claude/get-shit-done/workflows/execute-plan.md
@/home/rafreid/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/30-architecture-foundation/30-01-SUMMARY.md
@src/renderer/state-manager.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Refactor renderer.js to use state-manager imports</name>
  <files>src/renderer/renderer.js, src/renderer/graph-renderer.js</files>
  <action>
Refactor the renderer to use centralized state:

1. Create `src/renderer/graph-renderer.js` as a copy of renderer.js

2. In graph-renderer.js, add import at top:
   ```javascript
   import { state, subscribe, setState, getState, initializeState, resetViewState } from './state-manager.js';
   ```

3. Replace all direct state variable references with state object access:
   - `currentGraphData` -> `state.currentGraphData`
   - `selectedProjectPath` -> `state.selectedProjectPath`
   - `currentState` -> `state.currentState`
   - `selectedNode` -> `state.selectedNode`
   - `treeData` -> `state.treeData`
   - `treeExpanded` -> `state.treeExpanded`
   - `is3D` -> `state.is3D`
   - `activityEntries` -> `state.activityEntries`
   - `activityUnreadCount` -> `state.activityUnreadCount`
   - `navigationHistory` -> `state.navigationHistory`
   - `navigationIndex` -> `state.navigationIndex`
   - `bookmarks` -> `state.bookmarks`
   - `inspectorNode` -> `state.inspectorNode`
   - `highlightedNodeId` -> `state.highlightedNodeId`

4. Remove the local state variable declarations (they're now in state-manager.js)

5. Keep non-shared state local (flashingNodes, nodeHeatMap, etc. - these are renderer-specific)

6. Update renderer.js to be a thin entry point:
   ```javascript
   // Entry point - imports and initializes graph renderer
   import './graph-renderer.js';
   ```

Use search-and-replace carefully. The renderer has ~7600 lines - systematic replacement is critical.
  </action>
  <verify>
Run: `npm run build` (esbuild bundles the renderer)
Verify: Build succeeds without errors
  </verify>
  <done>
graph-renderer.js imports from state-manager.js, all state access uses state object, renderer.js is thin entry point
  </done>
</task>

<task type="auto">
  <name>Task 2: Add lifecycle methods and animation frame cleanup</name>
  <files>src/renderer/graph-renderer.js</files>
  <action>
Add explicit lifecycle management to graph-renderer.js:

1. Create a module-level registry for all animation frame IDs:
   ```javascript
   // Animation frame tracking for cleanup
   const animationFrameIds = {
     heatLoop: null,
     trailLoop: null,
     minimap: null,
     orbit: null,
     particles: null,
     // Add any others found in the file
   };
   ```

2. Update all requestAnimationFrame calls to register their IDs:
   - heatLoopRafId -> animationFrameIds.heatLoop
   - trailLoopRafId -> animationFrameIds.trailLoop
   - minimapRafId -> animationFrameIds.minimap
   - orbitAnimationId -> animationFrameIds.orbit

3. Create mount() function:
   ```javascript
   export function mount(containerEl) {
     // Start animation loops
     startHeatLoop();
     startTrailLoop();
     startMinimapLoop();
     // Initialize graph in container
     // Register event listeners
   }
   ```

4. Create unmount() function:
   ```javascript
   export function unmount() {
     // Cancel all animation frames
     Object.keys(animationFrameIds).forEach(key => {
       if (animationFrameIds[key]) {
         cancelAnimationFrame(animationFrameIds[key]);
         animationFrameIds[key] = null;
       }
     });

     // Cancel flash animations
     flashingNodes.forEach((anim, nodeId) => {
       if (anim.rafId) cancelAnimationFrame(anim.rafId);
     });
     flashingNodes.clear();

     // Clear intervals
     if (playbackInterval) clearInterval(playbackInterval);
     if (pathPlaybackTimeoutId) clearTimeout(pathPlaybackTimeoutId);

     // Reset view state
     resetViewState();
   }
   ```

5. Create getGraph() export for external access to the ForceGraph3D instance

6. Export the lifecycle methods:
   ```javascript
   export { mount, unmount, getGraph };
   ```

Ensure every requestAnimationFrame has a corresponding cancelAnimationFrame path.
  </action>
  <verify>
Run: `grep -c "cancelAnimationFrame" src/renderer/graph-renderer.js`
Verify: Count is >= 8 (one for each animation loop type)
Run: `grep "export.*mount\|export.*unmount" src/renderer/graph-renderer.js`
Verify: Both mount and unmount are exported
  </verify>
  <done>
mount() and unmount() lifecycle methods exist, all animation frame IDs tracked in registry and canceled on unmount
  </done>
</task>

</tasks>

<verification>
1. Build succeeds: `npm run build`
2. State imports present: `grep "import.*state-manager" src/renderer/graph-renderer.js`
3. Lifecycle exports: `grep "export.*mount" src/renderer/graph-renderer.js`
4. Animation cleanup: `grep -c "cancelAnimationFrame" src/renderer/graph-renderer.js` shows >= 8
5. App runs: `npm start` launches without errors
</verification>

<success_criteria>
- graph-renderer.js imports state from state-manager.js
- All shared state access uses state.* pattern
- mount() and unmount() lifecycle methods exported
- All animation frame IDs tracked and canceled on unmount
- App builds and runs without errors
</success_criteria>

<output>
After completion, create `.planning/phases/30-architecture-foundation/30-02-SUMMARY.md`
</output>

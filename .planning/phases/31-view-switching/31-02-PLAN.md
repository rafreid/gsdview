---
phase: 31-view-switching
plan: 02
type: execute
wave: 2
depends_on: ["31-01"]
files_modified:
  - src/renderer/view-controller.js
  - src/renderer/graph-renderer.js
  - src/renderer/index.html
autonomous: true

must_haves:
  truths:
    - "User's selected node persists when switching views"
    - "Keyboard shortcuts (1-9 bookmarks) work in graph view after switch"
    - "File watcher updates trigger flash animations after view switch"
    - "Graph view responds to arrow navigation after switch"
  artifacts:
    - path: "src/renderer/view-controller.js"
      provides: "Selection persistence and keyboard routing"
      contains: "preserveSelection"
    - path: "src/renderer/graph-renderer.js"
      provides: "Re-highlight on mount for persisted selection"
      contains: "restoreSelection"
  key_links:
    - from: "view-controller.js"
      to: "state-manager.js"
      via: "getState('selectedNode') before unmount"
      pattern: "getState.*selectedNode"
    - from: "graph-renderer.js mount"
      to: "state.selectedNode"
      via: "re-highlight on mount"
      pattern: "mount.*selectedNode"
---

<objective>
Wire selection persistence across view switches and ensure keyboard shortcuts route correctly.

Purpose: Users expect their context (selected node) to persist when switching views. Keyboard shortcuts like 1-9 bookmarks and arrow navigation must work correctly in the active view.

Output: Selection preserved on view switch, keyboard shortcuts functional after switching, file watcher updates animate correctly in graph view.
</objective>

<execution_context>
@/home/rafreid/.claude/get-shit-done/workflows/execute-plan.md
@/home/rafreid/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/31-view-switching/31-01-SUMMARY.md
@src/renderer/state-manager.js
@src/renderer/view-controller.js
@src/renderer/graph-renderer.js (search for keyboard handlers and selection logic)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add selection restoration on graph mount</name>
  <files>src/renderer/graph-renderer.js</files>
  <action>
Enhance the mount() function in graph-renderer.js to restore selection state:

1. Find the mount() function (around line 7692)

2. Add selection restoration after animation loop restarts:

```javascript
export function mount(containerEl) {
  console.log('[Lifecycle] Mounting graph renderer');

  // Start animation loops that were stopped during unmount
  if (nodeHeatMap.size > 0 && !heatLoopRunning) {
    startHeatDecayLoop();
  }

  if (activityTrails.length > 0 && !trailLoopRunning) {
    startTrailAnimationLoop();
  }

  if (!minimapRafId) {
    startMinimapUpdateLoop();
  }

  // Restore selection state if a node was selected before unmount
  const selectedNodeId = state.selectedNode;
  if (selectedNodeId && Graph) {
    console.log('[Lifecycle] Restoring selection:', selectedNodeId);

    // Find the node in current graph data
    const node = state.currentGraphData.nodes.find(n => n.id === selectedNodeId);
    if (node) {
      // Re-highlight the node visually (update material if needed)
      // The details panel should already be visible via state
      updateNodeHighlight(selectedNodeId);
    }
  }

  console.log('[Lifecycle] Graph renderer mounted');
}
```

3. Add a helper function updateNodeHighlight() if it doesn't exist, OR use existing highlightNode logic:

Search for existing highlight logic (look for highlightedNodeId usage). If there's a function that handles node highlighting, call it. Otherwise, create a minimal one:

```javascript
/**
 * Update visual highlight for a node
 * @param {string} nodeId - Node to highlight
 */
function updateNodeHighlight(nodeId) {
  if (!nodeId) return;

  // Update state
  state.highlightedNodeId = nodeId;

  // The graph's nodeThreeObject callback will handle visual updates
  // on the next render cycle - force a graph refresh
  if (Graph) {
    Graph.nodeThreeObject(Graph.nodeThreeObject());
  }
}
```

Note: The existing code likely already has node highlighting logic tied to highlightedNodeId. Review the nodeThreeObject callback to understand how highlighting works, and reuse that pattern.
  </action>
  <verify>
Run `npm run build` - succeeds without errors.
grep for "Restoring selection" in graph-renderer.js to confirm the logic was added.
  </verify>
  <done>
- mount() function restores selection from state.selectedNode
- Console logs show restoration happening
- Build succeeds
  </done>
</task>

<task type="auto">
  <name>Task 2: Add keyboard event routing based on active view</name>
  <files>src/renderer/view-controller.js, src/renderer/graph-renderer.js</files>
  <action>
1. Review existing keyboard handlers in graph-renderer.js:
   - Search for document.addEventListener('keydown' to find keyboard handlers
   - Note what shortcuts exist (1-9 for bookmarks, arrows, Escape, etc.)

2. Update view-controller.js to add view-aware routing:

```javascript
// Add at the end of initViewSwitching() or create a separate function:

/**
 * Setup keyboard routing based on active view
 * Keyboard events are routed to the active view's handlers
 */
function setupKeyboardRouting() {
  // The existing graph-renderer.js keyboard handlers check if modals are open
  // We need to add a view check at the start of those handlers

  // For now, keyboard handlers in graph-renderer.js should check:
  // if (getActiveView() !== 'graph') return;

  // This will be done by exporting getActiveView and checking it in graph-renderer
  console.log('[ViewCtrl] Keyboard routing: events route to active view');
}
```

3. Update graph-renderer.js keyboard handlers to check active view:

Find the keyboard event listeners (document.addEventListener('keydown', ...)) and add a guard:

```javascript
// At the top of graph-renderer.js, add import:
import { getActiveView } from './view-controller.js';

// In each keyboard handler, add early return:
document.addEventListener('keydown', (e) => {
  // Only handle keyboard in graph view
  if (getActiveView() !== 'graph') return;

  // ... existing handler code
});
```

Note: Be careful about circular dependencies. If this causes issues, alternative approach:
- Store activeView in state-manager.js instead
- Both view-controller.js and graph-renderer.js read from state

If circular dependency detected during build, use the state-manager approach:
- Add `activeView: 'graph'` to state-manager.js DEFAULT_STATE and rawState
- view-controller.js sets state.activeView instead of local variable
- graph-renderer.js reads state.activeView for keyboard checks
  </action>
  <verify>
Run `npm run build` - build succeeds without circular dependency errors.
grep for "getActiveView" or "activeView" in graph-renderer.js to confirm guard added.
  </verify>
  <done>
- Keyboard handlers in graph-renderer.js check active view
- Build succeeds without circular dependency issues
- Handlers only fire when graph view is active
  </done>
</task>

<task type="auto">
  <name>Task 3: Verify file watcher updates route correctly</name>
  <files>src/renderer/graph-renderer.js</files>
  <action>
1. Find the IPC listener that receives file change events:
   - Search for 'file-changed' or 'directory-updated' in graph-renderer.js
   - This is where the file watcher notifies the renderer

2. Verify the handler works correctly after view switch:
   - The handler should check if graph view is active before triggering flash animations
   - If already checking, no change needed
   - If not checking, add the guard:

```javascript
// In the IPC handler for file changes:
window.electron.on('file-changed', (event, data) => {
  // Always update state/data regardless of view
  // (so diagram view can pick up changes too)

  // Only trigger visual effects if graph view is active
  if (getActiveView() !== 'graph') {
    console.log('[FileWatcher] Graph not active, skipping flash animation');
    return;
  }

  // ... existing flash animation logic
});
```

3. Ensure the applyIncrementalUpdate function (if exists) also checks view state.

Note: File watcher updates should ALWAYS update the data (state.currentGraphData), but visual effects like flash animations should only trigger if graph view is active. This prevents:
- Wasted CPU on animations user can't see
- Race conditions with diagram view
- Memory buildup from queued animations
  </action>
  <verify>
grep for "file-changed" or "directory-updated" in graph-renderer.js.
Confirm the handler has view check or data flows to state regardless of view.
  </verify>
  <done>
- File watcher updates state regardless of active view
- Flash animations only trigger when graph view is active
- No race conditions between views
  </done>
</task>

</tasks>

<verification>
1. Run `npm run build` - build succeeds
2. Check selection restoration:
   - `grep "Restoring selection" src/renderer/graph-renderer.js`
3. Check keyboard routing:
   - `grep "getActiveView\|activeView" src/renderer/graph-renderer.js`
4. Check file watcher routing:
   - `grep "getActiveView\|activeView" src/renderer/graph-renderer.js | grep -i file\|flash`
5. Run `npm start` to verify app launches (manual test)
</verification>

<success_criteria>
1. mount() restores selection from state.selectedNode
2. Keyboard handlers check active view before processing
3. File watcher updates don't trigger graph animations when diagram is active
4. Build succeeds without circular dependency errors
5. App launches and runs without console errors
</success_criteria>

<output>
After completion, create `.planning/phases/31-view-switching/31-02-SUMMARY.md`
</output>

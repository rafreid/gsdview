---
phase: 26-hook-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - .claude/settings.json
  - .gsd-viewer/hooks/notify-electron.sh
  - .gsd-viewer/events/.gitkeep
autonomous: true

must_haves:
  truths:
    - "Claude Code hooks execute on Read/Write/Edit operations"
    - "Hook script writes event files to .gsd-viewer/events/ directory"
    - "Event files contain operation type, file path, and timestamp"
    - "Hook script exits immediately without blocking Claude operations"
  artifacts:
    - path: ".claude/settings.json"
      provides: "Claude Code PostToolUse hooks configuration"
      contains: "PostToolUse.*Read.*Write.*Edit"
    - path: ".gsd-viewer/hooks/notify-electron.sh"
      provides: "Bash observer script that writes event files"
      min_lines: 50
    - path: ".gsd-viewer/events/.gitkeep"
      provides: "Event files directory (empty placeholder)"
  key_links:
    - from: ".claude/settings.json"
      to: ".gsd-viewer/hooks/notify-electron.sh"
      via: "hooks.PostToolUse.command path"
      pattern: "\\.gsd-viewer/hooks/notify-electron\\.sh"
    - from: ".gsd-viewer/hooks/notify-electron.sh"
      to: ".gsd-viewer/events/"
      via: "event file write operations"
      pattern: "\\$EVENT_DIR|events/"
---

<objective>
Set up Claude Code hooks infrastructure to capture file operations and write structured event files to a watched directory.

Purpose: Provides the foundational hook integration that enables real-time visualization of Claude's file operations (Read, Write, Edit). This phase establishes the event communication pattern that phases 27-29 will consume.

Output: Working Claude Code hooks that fire on file operations and write event files with operation metadata to `.gsd-viewer/events/` directory, validated through manual testing.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/research/SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Claude Code hooks configuration</name>
  <files>.claude/settings.json</files>
  <action>
Create `.claude/settings.json` with PostToolUse hooks that fire on Read, Write, and Edit operations.

Hook configuration structure:
- Match tools: Read, Write, Edit (case-sensitive)
- Command: Execute `.gsd-viewer/hooks/notify-electron.sh` bash script
- Pass JSON stdin to script (Claude automatically provides tool operation details)
- Non-blocking: hooks should not affect Claude operation performance

Key requirements from research (SUMMARY.md):
- PostToolUse hooks fire AFTER tool execution with structured JSON payload
- Hook script receives JSON on stdin with fields: tool, parameters, timestamp
- Must use absolute path to hook script or ensure relative path resolution
- Critical: Always exit 0 from hook script to never block Claude

Event deduplication consideration:
- Hooks can fire twice from home directory (known issue #3465)
- Don't try to solve in hooks config - handle in Phase 2 (chokidar layer)

Configuration format (based on Claude Code hooks API):
```json
{
  "hooks": {
    "PostToolUse": {
      "Read": {
        "command": ".gsd-viewer/hooks/notify-electron.sh",
        "description": "Notify GSD Viewer of file read operations"
      },
      "Write": {
        "command": ".gsd-viewer/hooks/notify-electron.sh",
        "description": "Notify GSD Viewer of file write operations"
      },
      "Edit": {
        "command": ".gsd-viewer/hooks/notify-electron.sh",
        "description": "Notify GSD Viewer of file edit operations"
      }
    }
  }
}
```

Note: Use relative path `.gsd-viewer/hooks/notify-electron.sh` since hooks run from project root. If hooks fail to fire during testing, add absolute path fallback logic in Phase 4.
  </action>
  <verify>
- File `.claude/settings.json` exists
- Contains "PostToolUse" hook configuration
- References all three tools: Read, Write, Edit
- Points to `.gsd-viewer/hooks/notify-electron.sh` script
- Valid JSON syntax (validate with `jq '.' .claude/settings.json`)
  </verify>
  <done>
Claude Code hooks configuration file exists with PostToolUse matchers for Read/Write/Edit tools pointing to bash observer script.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create bash hook observer script</name>
  <files>.gsd-viewer/hooks/notify-electron.sh</files>
  <action>
Create `.gsd-viewer/hooks/notify-electron.sh` bash script that:
1. Reads JSON from stdin (Claude hook payload)
2. Parses operation type, file path, timestamp
3. Writes event file to `.gsd-viewer/events/` directory
4. Exits immediately (non-blocking)

Script requirements from research:
- Always exit 0 (never block Claude operations)
- Log errors to file, not stderr (stderr blocks hooks)
- Use atomic write pattern (write temp file, then mv)
- Event file naming: `{timestamp}-{operation}-{hash}.json`
- Include schema version for future evolution

Event file schema (must match Phase 2 expectations):
```json
{
  "schema_version": "1.0",
  "timestamp": 1234567890123,
  "operation": "read|write|edit",
  "file_path": "/absolute/path/to/file.txt",
  "tool": "Read|Write|Edit",
  "source": "claude-code"
}
```

Script structure:
```bash
#!/usr/bin/env bash
set -euo pipefail

# Critical: All errors to file, never to stderr (blocks Claude)
ERROR_LOG=".gsd-viewer/hooks/errors.log"
EVENT_DIR=".gsd-viewer/events"

# Function to log errors without blocking
log_error() {
  echo "[$(date -Iseconds)] ERROR: $1" >> "$ERROR_LOG" 2>/dev/null || true
}

# Ensure event directory exists
mkdir -p "$EVENT_DIR" 2>/dev/null || log_error "Failed to create event directory"

# Read JSON from stdin (provided by Claude hook)
HOOK_INPUT=$(cat)

# Parse JSON fields using jq (if available) or grep fallback
# Tool name: Read, Write, Edit
# File path: parameters.file_path or parameters.path
# Timestamp: Unix milliseconds

# Map tool to operation type
# Read -> read, Write -> write, Edit -> edit

# Generate event file with schema
# Filename: {timestamp}-{operation}-{random}.json
# Use mktemp pattern for uniqueness

# Atomic write: write to temp, then mv
# This prevents chokidar from reading partial files

# Always exit 0
exit 0
```

Key implementation notes:
- Use `jq` if available, fallback to grep/sed patterns
- Hash based on file_path + timestamp (200ms window) for dedup in Phase 2
- Don't implement deduplication here - let Phase 2 handle it
- Make script executable: `chmod +x`
- Test with manual JSON: `echo '{"tool":"Read","parameters":{"file_path":"test.txt"}}' | .gsd-viewer/hooks/notify-electron.sh`

Error handling:
- If jq missing: use grep/sed (less reliable but functional)
- If mkdir fails: log error and exit 0 (never block)
- If write fails: log error and exit 0
- If parse fails: log error and exit 0

Performance:
- Should complete in <50ms (file write is fast)
- No network calls, no heavy processing
- Minimal bash operations only
  </action>
  <verify>
- File `.gsd-viewer/hooks/notify-electron.sh` exists
- File is executable (`ls -l` shows `x` permission)
- Script contains error logging to file (not stderr)
- Script creates event files in `.gsd-viewer/events/`
- Script exits 0 in all code paths
- Manual test: `echo '{"tool":"Read","parameters":{"file_path":"test.txt"},"timestamp":1234567890}' | .gsd-viewer/hooks/notify-electron.sh` creates event file
- Event file contains valid JSON with schema_version, timestamp, operation, file_path fields
  </verify>
  <done>
Bash observer script exists, is executable, reads JSON from stdin, writes structured event files to `.gsd-viewer/events/`, and always exits 0 without blocking.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create event directory structure</name>
  <files>.gsd-viewer/events/.gitkeep</files>
  <action>
Create `.gsd-viewer/events/` directory structure for hook-generated event files.

Directory structure:
```
.gsd-viewer/
├── hooks/
│   ├── notify-electron.sh (from Task 2)
│   └── errors.log (created by script on errors)
└── events/
    └── .gitkeep (empty placeholder)
```

Create `.gsd-viewer/events/.gitkeep` to ensure directory is tracked by git but event files themselves are ignored (they're ephemeral - created by hooks, consumed by chokidar, then cleaned up).

Update `.gitignore` to ignore event files:
```
.gsd-viewer/events/*.json
.gsd-viewer/hooks/errors.log
```

Rationale for gitignore:
- Event files are ephemeral (created, read, deleted within seconds)
- Error log may contain sensitive file paths
- Only directory structure should be committed
- .gitkeep ensures empty directory is tracked
  </action>
  <verify>
- Directory `.gsd-viewer/events/` exists
- File `.gsd-viewer/events/.gitkeep` exists (empty file)
- Directory `.gsd-viewer/hooks/` exists
- `.gitignore` includes `.gsd-viewer/events/*.json` and `.gsd-viewer/hooks/errors.log` patterns
- Running `git status` shows `.gsd-viewer/` directories but not event files
  </verify>
  <done>
Event directory structure created with gitkeep placeholder, and gitignore configured to exclude ephemeral event files while tracking directory structure.
  </done>
</task>

</tasks>

<verification>

## End-to-End Hook Test

After all tasks complete, verify hook infrastructure works:

### Manual Hook Simulation

```bash
# 1. Test bash script directly
echo '{"tool":"Read","parameters":{"file_path":"test.txt"},"timestamp":1234567890}' | .gsd-viewer/hooks/notify-electron.sh

# 2. Verify event file created
ls -la .gsd-viewer/events/
# Should see: {timestamp}-read-{hash}.json

# 3. Verify event file content
cat .gsd-viewer/events/{newest-file}.json
# Should contain: schema_version, timestamp, operation, file_path, source fields
# Should be valid JSON: jq '.' .gsd-viewer/events/{file}.json

# 4. Verify script exits 0
echo $?
# Should output: 0

# 5. Test with Write and Edit operations
echo '{"tool":"Write","parameters":{"file_path":"test2.txt"},"timestamp":1234567891}' | .gsd-viewer/hooks/notify-electron.sh
echo '{"tool":"Edit","parameters":{"file_path":"test3.txt"},"timestamp":1234567892}' | .gsd-viewer/hooks/notify-electron.sh

# 6. Verify multiple event files
ls .gsd-viewer/events/*.json | wc -l
# Should output: 3 (or more if previous tests left files)
```

### Claude Code Hook Test (if in Claude Code environment)

```bash
# 1. Trigger a Read operation
# In Claude Code, use Read tool on any file in project
# Example: "Read the package.json file"

# 2. Check for event file
ls -lt .gsd-viewer/events/ | head -5
# Should see new event file with recent timestamp

# 3. Inspect event file
cat .gsd-viewer/events/{newest-file}.json | jq '.'
# Should show Read operation with correct file path
```

### Error Handling Test

```bash
# 1. Test with malformed JSON
echo 'invalid json' | .gsd-viewer/hooks/notify-electron.sh

# 2. Verify script still exits 0
echo $?
# Should output: 0

# 3. Check error log
cat .gsd-viewer/hooks/errors.log
# Should contain error message about JSON parsing

# 4. Test with missing fields
echo '{"tool":"Read"}' | .gsd-viewer/hooks/notify-electron.sh

# 5. Verify graceful degradation
# Script should exit 0, possibly log error, not block
```

## Success Indicators

- [ ] `.claude/settings.json` has PostToolUse hooks for Read/Write/Edit
- [ ] `.gsd-viewer/hooks/notify-electron.sh` is executable and non-blocking
- [ ] Manual JSON piped to script creates event file in `.gsd-viewer/events/`
- [ ] Event files contain valid JSON with required schema fields
- [ ] Script always exits 0, even with malformed input
- [ ] Error log created on failures (not stderr output)
- [ ] Multiple operations create separate event files
- [ ] `.gitignore` prevents committing ephemeral event files

</verification>

<success_criteria>

## Measurable Completion

**Phase 26 is complete when:**

1. **Hook Configuration Deployed**
   - `.claude/settings.json` exists with PostToolUse hooks
   - Hooks configured for Read, Write, Edit tools
   - Hooks point to `.gsd-viewer/hooks/notify-electron.sh`

2. **Observer Script Functional**
   - Bash script exists and is executable
   - Script reads JSON from stdin
   - Script writes event files to `.gsd-viewer/events/`
   - Script completes in <50ms (non-blocking)
   - Script always exits 0

3. **Event Files Generated**
   - Manual test creates event file
   - Event file contains: schema_version, timestamp, operation, file_path, source
   - Event file is valid JSON
   - Multiple operations create multiple files

4. **Error Handling Verified**
   - Malformed JSON doesn't block script
   - Errors logged to file, not stderr
   - Missing fields handled gracefully

5. **Git Integration Clean**
   - Directory structure committed (`.gsd-viewer/hooks/`, `.gsd-viewer/events/`)
   - Event files ignored by git
   - Error log ignored by git

## Readiness for Phase 27

Phase 27 (Chokidar Extension & IPC) can begin when:
- Event files are reliably created by hook script
- Event file schema is stable and documented
- Manual testing confirms end-to-end hook execution

</success_criteria>

<output>
After completion, create `.planning/phases/26-hook-infrastructure/26-01-SUMMARY.md`

Summary should document:
- Hook configuration structure
- Event file schema (critical for Phase 27)
- Testing results (manual and Claude Code if available)
- Known limitations (duplicate hook fires, working directory issues)
- Error handling patterns
- Performance characteristics (script execution time)
</output>
